<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SPACE BLOG</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-11T15:54:15.090Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>dddxmx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何画出高端的折线图？</title>
    <link href="http://example.com/2021/10/08/%E5%A6%82%E4%BD%95%E7%94%BB%E5%87%BA%E9%AB%98%E7%AB%AF%E7%9A%84%E6%8A%98%E7%BA%BF%E5%9B%BE%EF%BC%9F/"/>
    <id>http://example.com/2021/10/08/%E5%A6%82%E4%BD%95%E7%94%BB%E5%87%BA%E9%AB%98%E7%AB%AF%E7%9A%84%E6%8A%98%E7%BA%BF%E5%9B%BE%EF%BC%9F/</id>
    <published>2021-10-08T08:02:55.000Z</published>
    <updated>2021-10-11T15:54:15.090Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在科研论文中，图表的重要性不言而喻。"><a href="#在科研论文中，图表的重要性不言而喻。" class="headerlink" title="在科研论文中，图表的重要性不言而喻。"></a>在科研论文中，图表的重要性不言而喻。</h4><p>为了画出高端的折线图，我在网上找了半天，费尽千辛万苦才终于找到，特此记录下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">p.random.seed(<span class="number">9615</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate df</span></span><br><span class="line">N = <span class="number">100</span></span><br><span class="line">df = pd.DataFrame((<span class="number">.1</span> * (np.random.random((N, <span class="number">5</span>)) - <span class="number">.5</span>)).cumsum(<span class="number">0</span>),</span><br><span class="line">                  columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot line + confidence interval</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.grid(<span class="literal">True</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> df.iteritems():</span><br><span class="line">    l, = ax.plot(val.index, val.values, label=key)</span><br><span class="line">    ax.fill_between(val.index,</span><br><span class="line">                    val.values * <span class="number">.7</span>, val.values * <span class="number">1.3</span>,</span><br><span class="line">                    color=l.get_color(), alpha=<span class="number">.3</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;line cahrt&#x27;</span>, size=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">legend = ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>其实重点就是fill_between()这个函数，实现上下扩张。</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://www.hualigs.cn/image/61645da629322.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;在科研论文中，图表的重要性不言而喻。&quot;&gt;&lt;a href=&quot;#在科研论文中，图表的重要性不言而喻。&quot; class=&quot;headerlink&quot; title=&quot;在科研论文中，图表的重要性不言而喻。&quot;&gt;&lt;/a&gt;在科研论文中，图表的重要性不言而喻。&lt;/h4&gt;&lt;p&gt;为了画出高端</summary>
      
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>稠密连接网络（DENSENET）</title>
    <link href="http://example.com/2021/05/07/%E7%A8%A0%E5%AF%86%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C%EF%BC%88DENSENET%EF%BC%89/"/>
    <id>http://example.com/2021/05/07/%E7%A8%A0%E5%AF%86%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C%EF%BC%88DENSENET%EF%BC%89/</id>
    <published>2021-05-07T06:19:48.000Z</published>
    <updated>2021-05-07T09:53:33.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>ResNet跨层连接设计的引申。</p><p><img src="https://www.hualigs.cn/image/6094dfe1c3929.jpg"></p><p>与ResNet的主要区别在于，DenseNet⾥模块B的输出不是像ResNet那样和模块A的输出相加，⽽是在通道维上连结。在这个设计⾥，模块A直接跟模块B后⾯的所有层连接在了⼀起。这也是它被称为“稠密连接”的原因.</p><h3 id="稠密块"><a href="#稠密块" class="headerlink" title="稠密块"></a>稠密块</h3><p>由多个conv_block组成，每个conv_block使用“批量归一化、激活和卷积”结构。conv_block的通道数控制了输出通道数相对于输⼊通道数的增⻓，因此也被称为增⻓率（growth rate）。</p><h3 id="DENSENET"><a href="#DENSENET" class="headerlink" title="DENSENET"></a>DENSENET</h3><p>⾸先使⽤同ResNet⼀样的单卷积层和最⼤池化层。</p><p>之后同ResNet⼀样是4个使用4个卷积层的稠密块，稠密块里的卷积层通道数（即增长率）设为32。每个稠密块后使用过渡层来减半高和宽以及通道数。</p><p>最后接上全局池化层和全连接层来输出。</p><h3 id="获取数据并训练模型"><a href="#获取数据并训练模型" class="headerlink" title="获取数据并训练模型"></a>获取数据并训练模型</h3><p>在Fashion-MNIST数据集上训练ResNet。</p><p>以下为完整代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh_pytorch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_block</span>(<span class="params">in_channels, out_channels</span>):</span></span><br><span class="line">    blk = nn.Sequential(nn.BatchNorm2d(in_channels), nn.ReLU(),</span><br><span class="line">                        nn.Conv2d(in_channels, out_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenseBLock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_convs, in_channels, out_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DenseBLock, self).__init__()</span><br><span class="line">        net = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):</span><br><span class="line">            in_c = in_channels + i * out_channels</span><br><span class="line">            net.append(conv_block(in_c, out_channels))</span><br><span class="line">        self.net = nn.ModuleList(net)</span><br><span class="line">        self.out_channels = in_channels + num_convs * out_channels</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">for</span> blk <span class="keyword">in</span> self.net:</span><br><span class="line">            Y = blk(X)</span><br><span class="line">            X = torch.cat((X, Y), dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transition_block</span>(<span class="params">in_channels, out_channels</span>):</span></span><br><span class="line">    blk = nn.Sequential(nn.BatchNorm2d(in_channels), nn.ReLU(), nn.Conv2d(in_channels, out_channels, kernel_size=<span class="number">1</span>),</span><br><span class="line">                        nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>), nn.BatchNorm2d(<span class="number">64</span>), nn.ReLU(),</span><br><span class="line">                    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br><span class="line">num_channels, growth_rate = <span class="number">64</span>, <span class="number">32</span></span><br><span class="line">num_convs_in_dense_blocks = [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, num_convs <span class="keyword">in</span> <span class="built_in">enumerate</span>(num_convs_in_dense_blocks):</span><br><span class="line">    DB = DenseBLock(num_convs, num_channels, growth_rate)</span><br><span class="line">    net.add_module(<span class="string">&quot;DenseBlock_%d&quot;</span> % i, DB)</span><br><span class="line">    num_channels = DB.out_channels</span><br><span class="line">    <span class="keyword">if</span> i != <span class="built_in">len</span>(num_convs_in_dense_blocks) - <span class="number">1</span>:</span><br><span class="line">        net.add_module(<span class="string">&quot;transition_block_%d&quot;</span> % i, transition_block(num_channels, num_channels // <span class="number">2</span>))</span><br><span class="line">        num_channels = num_channels // <span class="number">2</span></span><br><span class="line">net.add_module(<span class="string">&quot;BN&quot;</span>, nn.BatchNorm2d(num_channels))</span><br><span class="line">net.add_module(<span class="string">&quot;relu&quot;</span>, nn.ReLU())</span><br><span class="line">net.add_module(<span class="string">&quot;global_avg_pool&quot;</span>, d2l.GlobalAvgPool2d())</span><br><span class="line">net.add_module(<span class="string">&quot;fc&quot;</span>, nn.Sequential(d2l.FlattenLayer(),</span><br><span class="line">                                   nn.Linear(num_channels, <span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line"><span class="comment"># 如出现“out of memory”的报错信息，可减⼩batch_size或resize</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size,</span><br><span class="line">                                                    resize=<span class="number">96</span>)</span><br><span class="line">lr, num_epochs = <span class="number">0.001</span>, <span class="number">5</span></span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr=lr)</span><br><span class="line">d2l.train_ch5(net, train_iter, test_iter, batch_size, optimizer,</span><br><span class="line">              device, num_epochs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://www.hualigs.cn/image/60950deb13475.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本质&quot;&gt;&lt;a href=&quot;#本质&quot; class=&quot;headerlink&quot; title=&quot;本质&quot;&gt;&lt;/a&gt;本质&lt;/h3&gt;&lt;p&gt;ResNet跨层连接设计的引申。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hualigs.cn/image/6094dfe</summary>
      
    
    
    
    <category term="Deep Learning" scheme="http://example.com/categories/Deep-Learning/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>残差网络（RESNET）</title>
    <link href="http://example.com/2021/05/05/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C%EF%BC%88RESNET%EF%BC%89/"/>
    <id>http://example.com/2021/05/05/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C%EF%BC%88RESNET%EF%BC%89/</id>
    <published>2021-05-05T15:54:27.000Z</published>
    <updated>2021-05-08T09:19:50.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>拟合出有关恒等映射的残差映射f(x)-x并将加权运算的权重和偏差参数学成0，那么f(x)即为恒等映射。</p><h3 id="残差块"><a href="#残差块" class="headerlink" title="残差块"></a>残差块</h3><p>⾸先有2个有相同输出通道数的3 * 3卷积层。每个卷积层后接⼀个批量归⼀化层和ReLU激活函数。然后我们将输⼊跳过这两个卷积运算后直接加在最后的ReLU激活函数前。这样的设计要求两个卷积层的输出与输⼊形状⼀样，从⽽可以相加。如果想改变通道数，就需要引⼊⼀个额外的1 * 1卷积层来将输⼊变换成需要的形状后再做相加运算。</p><h3 id="残差网络"><a href="#残差网络" class="headerlink" title="残差网络"></a>残差网络</h3><p>首先是输出通道数为64、步幅为2的7 * 7卷积层后接一个批量归⼀化层再接一个步幅为2的3 * 3的最⼤池化层。</p><p>之后是4个由残差块组成的模块，每个模块使⽤若⼲个同样输出通道数的残差块（本文中为两个）。第⼀个模块的通道数同输⼊通道数⼀致。</p><p>最后加⼊全局平均池化层后接上全连接层输出。</p><p>这⾥每个模块⾥有4个卷积层（不计算1 * 1卷积层），加上最开始的卷积层和最后的全连接层，共计18层。这个模型通常也被称为ResNet-18。</p><h3 id="获取数据和训练模型"><a href="#获取数据和训练模型" class="headerlink" title="获取数据和训练模型"></a>获取数据和训练模型</h3><p>在Fashion-MNIST数据集上训练ResNet。</p><p>以下为完整代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh_pytorch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet_block</span>(<span class="params">in_channels, out_channels, num_residuals, first_block=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> first_block:</span><br><span class="line">        <span class="keyword">assert</span> in_channels == out_channels</span><br><span class="line">    blk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block:</span><br><span class="line">            blk.append(d2l.Residual(in_channels, out_channels, use_1x1conv=<span class="literal">True</span>, stride=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(d2l.Residual(out_channels, out_channels))</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(*blk)</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>), nn.BatchNorm2d(<span class="number">64</span>), nn.ReLU(),</span><br><span class="line">                    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br><span class="line">net.add_module(<span class="string">&quot;resnet_block1&quot;</span>, resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>,</span><br><span class="line">                                             first_block=<span class="literal">True</span>))</span><br><span class="line">net.add_module(<span class="string">&quot;resnet_block2&quot;</span>, resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">net.add_module(<span class="string">&quot;resnet_block3&quot;</span>, resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">net.add_module(<span class="string">&quot;resnet_block4&quot;</span>, resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br><span class="line">net.add_module(<span class="string">&quot;global_avg_pool&quot;</span>,d2l.GlobalAvgPool2d())</span><br><span class="line">net.add_module(<span class="string">&quot;fc&quot;</span>,nn.Sequential(d2l.FlattenLayer(),nn.Linear(<span class="number">512</span>,<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line"><span class="comment"># 如出现“out of memory”的报错信息，可减⼩batch_size或resize</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size,</span><br><span class="line">                                                    resize=<span class="number">96</span>)</span><br><span class="line">lr, num_epochs = <span class="number">0.001</span>, <span class="number">5</span></span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr=lr)</span><br><span class="line">d2l.train_ch5(net, train_iter, test_iter, batch_size, optimizer,</span><br><span class="line">              device, num_epochs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://www.hualigs.cn/image/6093ffc9cb176.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本质&quot;&gt;&lt;a href=&quot;#本质&quot; class=&quot;headerlink&quot; title=&quot;本质&quot;&gt;&lt;/a&gt;本质&lt;/h3&gt;&lt;p&gt;拟合出有关恒等映射的残差映射f(x)-x并将加权运算的权重和偏差参数学成0，那么f(x)即为恒等映射。&lt;/p&gt;
&lt;h3 id=&quot;残差块&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Deep Learning" scheme="http://example.com/categories/Deep-Learning/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用重复元素的网络（VGG）</title>
    <link href="http://example.com/2021/05/05/%E4%BD%BF%E7%94%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E7%BD%91%E7%BB%9C%EF%BC%88VGG%EF%BC%89/"/>
    <id>http://example.com/2021/05/05/%E4%BD%BF%E7%94%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E7%BD%91%E7%BB%9C%EF%BC%88VGG%EF%BC%89/</id>
    <published>2021-05-05T09:49:23.000Z</published>
    <updated>2021-05-06T15:15:48.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>通过重复使⽤简单的基础块来构建深度模型。</p><h3 id="VGG块"><a href="#VGG块" class="headerlink" title="VGG块"></a>VGG块</h3><p>组成规律是：连续使⽤数个相同的填充为1、窗⼝形状为3 * 3的卷积层后接上⼀个步幅为2、窗⼝形状为2 * 2的最⼤池化层。卷积层保持输⼊的⾼和宽不变，⽽池化层则对其减半。</p><p>VGG这种⾼和宽减半以及通道翻倍的设计使得多数卷积层都有相同的模型参数尺⼨和计算复杂度。</p><h3 id="VGG网络"><a href="#VGG网络" class="headerlink" title="VGG网络"></a>VGG网络</h3><p>由卷积层模块后接全连接层模块构成。变量conv_arch 指定了每个VGG块⾥卷积层个数和输⼊输出通道数。</p><p>本文中的网络有5个卷积块，前2块使⽤单卷积层，⽽后3块使⽤双卷积层。第⼀块的输⼊输出通道分别是1（因为下⾯要使⽤的Fashion-MNIST数据的通道数为1）和64，之后每次对输出通道数翻倍，直到变为512。因为这个⽹络使⽤了8个卷积层和3个全连接层，所以经常被称为VGG-11。</p><h3 id="获取数据和训练模型"><a href="#获取数据和训练模型" class="headerlink" title="获取数据和训练模型"></a>获取数据和训练模型</h3><p>在Fashion-MNIST数据集上进⾏训练。</p><p>以下为完整代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh_pytorch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg_block</span>(<span class="params">num_convs, in_channels, out_channels</span>):</span></span><br><span class="line">    blk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            blk.append(nn.Conv2d(in_channels, out_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>))</span><br><span class="line">        blk.append(nn.ReLU())</span><br><span class="line">    blk.append(nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(*blk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg</span>(<span class="params">conv_arch, fc_features, fc_hidden_units=<span class="number">4096</span></span>):</span></span><br><span class="line">    net = nn.Sequential()</span><br><span class="line">    <span class="keyword">for</span> i, (num_convs, in_channels, out_channels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(conv_arch):</span><br><span class="line">        net.add_module(<span class="string">&quot;vgg_block_&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>), vgg_block(num_convs, in_channels, out_channels))</span><br><span class="line">    net.add_module(<span class="string">&quot;fc&quot;</span>, nn.Sequential(d2l.FlattenLayer(), nn.Linear(fc_features, fc_hidden_units), nn.ReLU(),</span><br><span class="line">                                       nn.Dropout(<span class="number">0.5</span>), nn.Linear(fc_hidden_units, fc_hidden_units), nn.ReLU(),</span><br><span class="line">                                       nn.Dropout(<span class="number">0.5</span>), nn.Linear(fc_hidden_units, <span class="number">10</span>)))</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conv_arch = ((<span class="number">1</span>, <span class="number">1</span>, <span class="number">64</span>), (<span class="number">1</span>, <span class="number">64</span>, <span class="number">128</span>), (<span class="number">2</span>, <span class="number">128</span>, <span class="number">256</span>), (<span class="number">2</span>, <span class="number">256</span>, <span class="number">512</span>), (<span class="number">2</span>, <span class="number">512</span>, <span class="number">512</span>))</span><br><span class="line">fc_features = <span class="number">512</span> * <span class="number">7</span> * <span class="number">7</span>  <span class="comment"># c * w * h</span></span><br><span class="line">fc_hidden_units = <span class="number">4096</span>  <span class="comment"># 任意</span></span><br><span class="line"></span><br><span class="line">ratio = <span class="number">16</span></span><br><span class="line">small_conv_arch = [(<span class="number">1</span>, <span class="number">1</span>, <span class="number">64</span> // ratio), (<span class="number">1</span>, <span class="number">64</span> // ratio, <span class="number">128</span> // ratio),</span><br><span class="line">                   (<span class="number">2</span>, <span class="number">128</span> // ratio, <span class="number">256</span> // ratio),</span><br><span class="line">                   (<span class="number">2</span>, <span class="number">256</span> // ratio, <span class="number">512</span> // ratio), (<span class="number">2</span>, <span class="number">512</span> // ratio,</span><br><span class="line">                                                     <span class="number">512</span> // ratio)]</span><br><span class="line">net = vgg(small_conv_arch, fc_features // ratio, fc_hidden_units //ratio)</span><br><span class="line"><span class="comment"># X = torch.rand(1, 1, 224, 224)</span></span><br><span class="line"><span class="comment"># # named_children获取⼀级⼦模块及其名字(named_modules会返回所有⼦模块,包括⼦模块的⼦模块)</span></span><br><span class="line"><span class="comment"># for name, blk in net.named_children():</span></span><br><span class="line"><span class="comment">#     X = blk(X)</span></span><br><span class="line"><span class="comment">#     print(name, &#x27;output shape: &#x27;, X.shape)</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line"><span class="comment"># 如出现“out of memory”的报错信息，可减⼩batch_size或resize</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size,</span><br><span class="line">                                                    resize=<span class="number">224</span>)</span><br><span class="line">lr, num_epochs = <span class="number">0.001</span>, <span class="number">5</span></span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr=lr)</span><br><span class="line">d2l.train_ch5(net, train_iter, test_iter, batch_size, optimizer,</span><br><span class="line">              device, num_epochs)</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://www.hualigs.cn/image/6093c40f8c755.jpg"></p><p>只能在cpu上跑的痛有谁懂/(ㄒoㄒ)/~~</p><p>没有gpu太煎熬了，快来个富婆包养我吧(❁´◡`❁)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;本质&quot;&gt;&lt;a href=&quot;#本质&quot; class=&quot;headerlink&quot; title=&quot;本质&quot;&gt;&lt;/a&gt;本质&lt;/h3&gt;&lt;p&gt;通过重复使⽤简单的基础块来构建深度模型。&lt;/p&gt;
&lt;h3 id=&quot;VGG块&quot;&gt;&lt;a href=&quot;#VGG块&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Deep Learning" scheme="http://example.com/categories/Deep-Learning/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GitHub加速</title>
    <link href="http://example.com/2021/04/25/GitHub%E5%8A%A0%E9%80%9F/"/>
    <id>http://example.com/2021/04/25/GitHub%E5%8A%A0%E9%80%9F/</id>
    <published>2021-04-25T15:03:23.000Z</published>
    <updated>2021-04-25T15:10:26.852Z</updated>
    
    <content type="html"><![CDATA[<p>因为某些原因，Github 访问速度确实太慢了，图片经常刷不出来，甚至会出现项目无法下载的情况</p><p>以下是几种提高Github 访问速度的方案。</p><h2 id="GitHub-镜像访问"><a href="#GitHub-镜像访问" class="headerlink" title="GitHub 镜像访问"></a><strong>GitHub 镜像访问</strong></h2><p>这里提供两个最常用的镜像地址：</p><ul><li><p>  <a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org</a></p></li><li><p>  <a href="https://hub.fastgit.org/">https://hub.fastgit.org</a></p></li></ul><p>也就是说上面的镜像就是一个克隆版的 GitHub，你可以访问上面的镜像网</p><p>网站的内容跟 GitHub 是完整同步的镜像，然后在这个网站里面进行下载克隆等操作</p><h2 id="GitHub-文件加速"><a href="#GitHub-文件加速" class="headerlink" title="GitHub 文件加速"></a><strong>GitHub 文件加速</strong></h2><p>利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带 CDN</p><ul><li><p>  <a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz</a></p></li><li><p>  <a href="https://g.ioiox.com/">https://g.ioiox.com</a></p></li></ul><p>以上网站为演示站点</p><p>如无法打开可以查看开源项目：gh-proxy-GitHub( <a href="https://hunsh.net/archives/23/">https://hunsh.net/archives/23/</a> ) 文件加速自行部署</p><h2 id="Github-加速下载"><a href="#Github-加速下载" class="headerlink" title="Github 加速下载"></a><strong>Github 加速下载</strong></h2><p>只需要复制当前 GitHub 地址粘贴到输入框中就可以代理加速下载！</p><p>地址：<a href="http://toolwa.com/github/">http://toolwa.com/github/</a></p><h2 id="加速你的-Github"><a href="#加速你的-Github" class="headerlink" title="加速你的 Github"></a><strong>加速你的 Github</strong></h2><p><a href="https://github.zhlh6.cn/">https://github.zhlh6.cn</a></p><p>输入 Github 仓库地址，使用生成的地址进行 git ssh 等操作</p><h2 id="谷歌浏览器-GitHub-加速插件-推荐"><a href="#谷歌浏览器-GitHub-加速插件-推荐" class="headerlink" title="谷歌浏览器 GitHub 加速插件(推荐)"></a><strong>谷歌浏览器 GitHub 加速插件(推荐)</strong></h2><h2 id="GitHub-raw-加速"><a href="#GitHub-raw-加速" class="headerlink" title="GitHub raw 加速"></a><strong>GitHub raw 加速</strong></h2><p>GitHub raw 域名并非 github.com 而是 raw.githubusercontent.com</p><p>上方的 GitHub 加速如果不能加速这个域名，那么可以使用 Static CDN 提供的反代服务</p><p>将 raw.githubusercontent.com 替换为 raw.staticdn.net 即可加速</p><h2 id="GitHub-Jsdelivr"><a href="#GitHub-Jsdelivr" class="headerlink" title="GitHub + Jsdelivr"></a><strong>GitHub + Jsdelivr</strong></h2><p>jsdelivr 唯一美中不足的就是它不能获取 exe 文件以及 Release 处附加的 exe 和 dmg 文件。</p><p>也就是说如果 exe 文件是附加在 Release 处但是没有在 code 里面的话是无法获取的</p><p>所以只能当作静态文件 cdn 用途，而不能作为 Release 加速下载的用途</p><h2 id="通过-Gitee-中转-fork-仓库下载"><a href="#通过-Gitee-中转-fork-仓库下载" class="headerlink" title="通过 Gitee 中转 fork 仓库下载"></a><strong>通过 Gitee 中转 fork 仓库下载</strong></h2><p>网上有很多相关的教程，这里简要的说明下操作。</p><p>访问 gitee 网站：<a href="https://gitee.com/">https://gitee.com/</a> 并登录，在顶部选择“从 GitHub/GitLab 导入仓库” 如下：</p><p>在导入页面中粘贴你的 Github 仓库地址，点击导入即可：</p><p>等待导入操作完成，然后在导入的仓库中下载浏览对应的该 GitHub 仓库代码，你也可以点击仓库顶部的 “刷新” 按钮进行 Github 代码仓库的同步</p><h2 id="通过修改-HOSTS-文件进行加速"><a href="#通过修改-HOSTS-文件进行加速" class="headerlink" title="通过修改 HOSTS 文件进行加速"></a><strong>通过修改 HOSTS 文件进行加速</strong></h2><p>手动把 cdn 和 ip 地址绑定</p><p>第一步：获取 github 的 global.ssl.fastly</p><p>访问地址：</p><p><a href="http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo">http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo</a> 获取 cdn 和 ip 域名</p><p>得到：199.232.69.194 <a href="https://github.global.ssl.fastly.net/">https://github.global.ssl.fastly.net</a></p><p>第二步：获取 github.com 地址</p><p>访问地址：</p><p><a href="https://github.com.ipaddress.com/#ipinfo">https://github.com.ipaddress.com/#ipinfo</a> 获取 cdn 和 ip</p><p>得到对应数据：</p><p>140.82.114.4 <a href="http://github.com/">http://github.com</a></p><p>第三步：修改 host 文件映射上面查找到的 IP</p><p>windows系统：</p><p>1、修改 C:\Windows\System32\drivers\etc\hosts 文件的权限，指定可写入</p><p>右击-&gt;hosts-&gt;属性-&gt;安全-&gt;编辑-&gt;点击Users-&gt;在 Users 的权限 “写入” 后面打勾</p><p>如下：</p><p>然后点击确定</p><p>2、右击-&gt;hosts-&gt;打开方式-&gt;选定记事本（或者你喜欢的编辑器）-&gt;在末尾处添加以下内容：<br>199.232.69.194 github.global.ssl.fastly.net<br>140.82.114.4 github.com</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为某些原因，Github 访问速度确实太慢了，图片经常刷不出来，甚至会出现项目无法下载的情况&lt;/p&gt;
&lt;p&gt;以下是几种提高Github 访问速度的方案。&lt;/p&gt;
&lt;h2 id=&quot;GitHub-镜像访问&quot;&gt;&lt;a href=&quot;#GitHub-镜像访问&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python踩坑</title>
    <link href="http://example.com/2021/04/18/Python%E8%B8%A9%E5%9D%91/"/>
    <id>http://example.com/2021/04/18/Python%E8%B8%A9%E5%9D%91/</id>
    <published>2021-04-18T15:32:20.000Z</published>
    <updated>2021-04-21T07:34:14.505Z</updated>
    
    <content type="html"><![CDATA[<p>最近用python在做项目，借此深刻认识到python果然是越学越难。</p><p>弱类型虽然方便，但也会导致各种各样意想不到的bug。</p><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在python中，万物皆是对象，变量名是访问到变量的唯一方式（通过引用访问）。</p><h3 id="变量存储"><a href="#变量存储" class="headerlink" title="变量存储"></a>变量存储</h3><p>内存中有两块区域：堆区与栈区。在定义变量时，变量名与值内存地址的关联关系存放与栈区，变量值存放于堆区。</p><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题，并且通过“分代回收”（generation collection）以空间换取时间的方式来进一步提高垃圾回收的效率。</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>变量值被关联次数的增加或减少，都会引发引用计数机制的执行（增加或减少值的引用计数），这存在明显的效率问题。</p><p>如果说执行效率还仅仅是引用计数机制的一个软肋的话，那么很不幸，引用计数机制还存在着一个致命的弱点，即循环引用（也称交叉引用）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1=[<span class="number">123</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2=[<span class="string">&quot;456&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1.append(l2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2.append(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(l1)</span><br><span class="line">[<span class="number">123</span>, [<span class="string">&#x27;456&#x27;</span>, [...]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(l2)</span><br><span class="line">[<span class="string">&#x27;456&#x27;</span>, [<span class="number">123</span>, [...]]]</span><br></pre></td></tr></table></figure><p>循环引用导致：即使值不被变量名引用，引用计数也不会为0。由于相互引用的存在，这些对象占用的内存永远不会被释放。所以Python引入了“标记-清除” 与“分代回收”来分别解决引用计数的循环引用与效率低的问题。</p><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p>标记的过程其实就是，遍历所有的GC Roots对象(栈区中的所有内容或者线程都可以作为GC Roots对象），然后将所有GC Roots的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除。<br>清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</p><h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）。</p><p>新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的GC扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低。</p><p>虽然分代回收可以起到提升效率的效果，但也存在一定的缺点：例如一个变量刚刚从新生代移入青春代，该变量的绑定关系就解除了，该变量应该被回收，但青春代的扫描频率低于新生代，所以该变量的回收就会被延迟。 </p><h3 id="可变对象和不可变对象"><a href="#可变对象和不可变对象" class="headerlink" title="可变对象和不可变对象"></a>可变对象和不可变对象</h3><p>可变对象包括list、set、dict等，不可变对象包括int、float、long、str、tuple等。</p><p>对于可变对象，对象的操作不会重建对象，而对不可变对象，每一次操作就会重建新的对象。</p><p>在函数参数传递时，其实就是把参数里传入的变量的对象的引用赋值给函数内部变量。</p><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>copy.copy 浅拷贝，只拷贝父对象，不会拷贝对象的内部的子对象。</p><p>copy.deepcopy 深拷贝，拷贝对象及其子对象。</p><p>除此以外，使用列表生成式，for循环遍历，使用切片都是浅拷贝方法。</p><h3 id="is与"><a href="#is与" class="headerlink" title="is与=="></a>is与==</h3><p>==只比较两个对象的内容是否相等，不比较地址。</p><p>is比较的是两个对象是否完全相同，即内容相同并且地址相同。</p><p>最后一条，None的bool值为False。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近用python在做项目，借此深刻认识到python果然是越学越难。&lt;/p&gt;
&lt;p&gt;弱类型虽然方便，但也会导致各种各样意想不到的bug。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Qt样式表</title>
    <link href="http://example.com/2021/04/14/Qt%E6%A0%B7%E5%BC%8F%E8%A1%A8/"/>
    <id>http://example.com/2021/04/14/Qt%E6%A0%B7%E5%BC%8F%E8%A1%A8/</id>
    <published>2021-04-14T12:09:04.000Z</published>
    <updated>2021-04-14T12:15:42.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Box样式"><a href="#Box样式" class="headerlink" title="Box样式"></a>Box样式</h3><p>width：宽度</p><p>height：高度</p><p>max-width：最大宽度</p><p>max-height：最大高度</p><p>min-width：最小宽度</p><p>min-height：最小高度</p><p>margin：边距尺寸</p><p>margin-top</p><p>margin-right</p><p>margin-bottom</p><p>margin-left</p><p>padding：填充尺寸</p><p>padding-top</p><p>padding-right</p><p>padding-bottom</p><p>padding-left</p><h3 id="位置样式"><a href="#位置样式" class="headerlink" title="位置样式"></a>位置样式</h3><p>position：定位属性</p><p>如果position是relative(默认值)，则将子控件移动一定的偏移量;如果position是absolute，则指定子控件相对于父控件位置</p><p>top</p><p>right</p><p>bottom</p><p>left</p><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p>font：字体样式</p><p>font-family：字体类型</p><p>font-size：字体大小</p><p>font-style：字体风格</p><p>font-weight：字体粗细</p><p>font-color：字体颜色</p><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><p>text-decoration：文本修饰</p><p>text-align：水平对齐</p><h3 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h3><p>background：背影样式</p><p>background-color：背景颜色</p><p>background-image：背景图片</p><p>background-repeat：背景重复</p><p>background-position：背景定位</p><p>background-attachment：背景固定</p><p>background-clip：设置元素的背景(背景图片或颜色)是否延伸到边框下面。</p><p>background-origin：指定背景图片background-image 属性的原点位置的背景相对区域</p><h3 id="边框样式"><a href="#边框样式" class="headerlink" title="边框样式"></a>边框样式</h3><p>border：边框样式</p><p>border-top</p><p>border-top-color</p><p>border-top-style</p><p>border-top-width</p><p>border-right</p><p>border-right-color</p><p>border-right-style</p><p>border-right-width</p><p>border-bottom</p><p>border-bottom-color</p><p>border-bottom-style</p><p>border-bottom-width</p><p>border-left</p><p>border-left-color</p><p>border-left-style</p><p>border-left-width</p><p>border-color：边框颜色</p><p>border-style：边框风格</p><p>border-width：边框宽度</p><p>border-image：边框图片</p><p>border-radius：元素的外边框圆角</p><p>border-top-left-radius</p><p>border-top-right-radius</p><p>border-bottom-right-radius</p><p>border-bottom-left-radius</p><h3 id="颜色样式"><a href="#颜色样式" class="headerlink" title="颜色样式"></a>颜色样式</h3><p>alternate-background-color：交替行颜色</p><p>gridline-color：QTableView中网格线的颜色</p><p>selection-color：所选文本或项目的前景色</p><p>selection-background-color：所选文本或项目的背景色</p><h3 id="轮廓样式"><a href="#轮廓样式" class="headerlink" title="轮廓样式"></a>轮廓样式</h3><p>outline：轮廓属性</p><p>outline-color：设置一个元素轮廓的颜色</p><p>outline-offset：设置 outline 与元素边缘或边框之间的间隙</p><p>outline-style：设置元素轮廓的样式</p><p>outline-radius：设置元素的轮廓圆角</p><p>outline-bottom-left-radius</p><p>outline-bottom-right-radius</p><p>outline-top-left-radius</p><p>outline-top-right-radius</p><h3 id="其他样式"><a href="#其他样式" class="headerlink" title="其他样式"></a>其他样式</h3><p>opacity：控件的不透明度</p><p>icon-size：控件中图标的宽度和高度。</p><p>image：在子控件的内容矩形中绘制的图像</p><p>image-position：在Qt 4.3及更高版本中，可以使用相对或绝对位置指定图像图像位置的对齐</p><p>spacing：控件中的内部间距</p><p>subcontrol-origin：父元素中子控件的原始矩形。</p><p>subcontrol-position：subcontrol-origin指定的原始矩形内子控件的对齐方式。</p><p>button-layout：QDialogButtonBox或QMessageBox中按钮的布局</p><p>messagebox-text-interaction-flags：消息框中文本的交互行为</p><p>dialogbuttonbox-buttons-have-icons：QDialogButtonBox中的按钮是否显示图标</p><p>titlebar-show-tooltips-on-buttons：是否在窗口标题栏按钮上显示工具提示。</p><p>widget-animation-duration：动画应该持续多少(以毫秒为单位)。值等于零意味着将禁用动画</p><p>lineedit-password-character：该QLineEdit的密码字符作为Unicode数字。</p><p>lineedit-password-mask-delay：在将lineedit-password-character应用于可见字符之前，QLineEdit密码掩码延迟(以毫秒为单位)</p><p>paint-alternating-row-colors-for-empty-area：QTreeView是否为空白区域(即没有项目的区域)绘制交替的行颜色</p><p>show-decoration-selected：控制QListView中的选择是覆盖整个行还是仅覆盖文本的范围。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Box样式&quot;&gt;&lt;a href=&quot;#Box样式&quot; class=&quot;headerlink&quot; title=&quot;Box样式&quot;&gt;&lt;/a&gt;Box样式&lt;/h3&gt;&lt;p&gt;width：宽度&lt;/p&gt;
&lt;p&gt;height：高度&lt;/p&gt;
&lt;p&gt;max-width：最大宽度&lt;/p&gt;
&lt;p&gt;max</summary>
      
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt控件</title>
    <link href="http://example.com/2021/04/14/QT%E6%8E%A7%E4%BB%B6/"/>
    <id>http://example.com/2021/04/14/QT%E6%8E%A7%E4%BB%B6/</id>
    <published>2021-04-14T00:27:13.000Z</published>
    <updated>2021-04-14T12:24:33.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Buttons"><a href="#Buttons" class="headerlink" title="Buttons"></a>Buttons</h3><h4 id="PushButton控件"><a href="#PushButton控件" class="headerlink" title="PushButton控件"></a>PushButton控件</h4><p>1）控件位置：Button-&gt;PushButton</p><p>2）控件介绍：该控件继承自QButton类，通常用于执行命令或触发事件。</p><p>3）控件属性设置选项：</p><p>（1）name：该控件对应源代码中的名字。</p><p>（2）text：该控件对应图形界面中显示的名字。</p><p>（3）font：设置text的字体。</p><p>（4）enabled：该控件是否可用。</p><p>4）常用成员函数：</p><p>（1）QPushButton：：QPushButton（const QString &amp;text，QWidget *parent，const char *name = 0）；</p><p>构造一个名称为name，父对象为parent并且文本为text的推动按钮。</p><p>（2）void QButton：：pressed（）[信号]</p><p>当按下该按钮时发射信号。</p><p>（3）void QButton：：clicked（）[信号]</p><p>当单击该按钮时发射信号。</p><p>（4）void QButton：：released（）[信号]</p><p>当释放该按钮时，发射信号。</p><p>（5）void QButton：：setText（const QString &amp;）</p><p>设置该按钮上显示的文本。</p><p>（6）QString QButton：：text（）const</p><p>返回该按钮上显示的文本。</p><h4 id="RadioButton控件"><a href="#RadioButton控件" class="headerlink" title="RadioButton控件"></a>RadioButton控件</h4><p>1）控件位置：Buttons-&gt;RadioButton</p><p>2）控件介绍：单选框，继承自QButton类，通常成组出现，用于提供两个或多个互斥选项。</p><p>3）控件属性设置选项：</p><p>（1）name：该控件对应源代码中所显示的名字。</p><p>（2）text：该控件对应图形界面中所显示的名字。</p><p>（3）font：设置text字体。</p><p>（4）enabled：该控件是否可用，可用为true，不可用为false。</p><p>（5）checked：用来设置或返回是否选中单选按钮，选中为true，未选中为false。</p><p>4）常用成员函数：</p><p>（1）QRaidoButton：：QRadioButton（const QString &amp;text，QWidget *parent，const char *name = 0）</p><p>构造一个名称为name、父对象为parent并且文本为text的单选按钮。</p><p>（2）bool QRadioButton：：isChecked（）const</p><p>返回是否选中单选按钮，选中时返回true，没有选中时返回false。</p><p>（3）void QButton：：setText（const QString &amp;）</p><p>设置该按钮上显示的文本。</p><p>（4）QString QButton：：text（）const</p><p>返回该按钮上显示的文本。</p><p>（5）void QButton：：stateChanged（int state）[signal]</p><p>当更改checked属性值时，将发射信号。</p><p>（6）void QRadioButton：：setChecked（bool check）[virtual slot]</p><p>设置单选按钮是否被选中为check。</p><h4 id="CheckBox控件"><a href="#CheckBox控件" class="headerlink" title="CheckBox控件"></a>CheckBox控件</h4><p>1）控件位置：Buttons-&gt;CheckBox</p><p>2）控件介绍：复选框，继承自QButton，与RadioButton的区别是选则模式，单选框提供多选一，复选框提供多选多。</p><p>3）控件属性设置选项：</p><p>（1）name：该控件对应源代码中所显示的名字。</p><p>（2）text：该控件对应图形界面中所显示的名字。</p><p>（3）font：设置text字体。</p><p>（4）enabled：该控件是否可用，可用为true，不可用为false。</p><p>（5）checked：用来设置或返回是否选中单选按钮，选中为true，未选中为false。</p><p>4）常用成员函数：</p><p>（1）QCheckBox：：QCheckBox（const QString &amp;text，QWidget *parent，const char *name = 0）</p><p>构造一个名称为name、父对象为parent并且文本为text的复选框。</p><p>（2）QCheckBox：：isChecked（）const</p><p>选中该复选框，返回true，否则返回false。</p><p>（3）void QButton：：setText（const QString &amp;）</p><p>设置该按钮上显示的文本。</p><p>（4）QString QButton：：text（）const</p><p>返回该按钮上显示的文本。</p><p>（5）void QButton：：stateChange（int state）[signal]</p><p>当更改checked属性时，将发射这个信号。</p><p>（6）void QCheckBox：：setChecked（bool check）[槽]</p><p>设置复选框是否选中，状态为check的值。</p><h4 id="ToolButton控件"><a href="#ToolButton控件" class="headerlink" title="ToolButton控件"></a>ToolButton控件</h4><p>1）控件位置：Buttons-&gt;ToolButton</p><p>2）控件介绍：工具按钮，继承自QButton类，是一种用于命令或者选项的可以快速访问的按钮，通常在ToolBar里面。工具按钮通常显示的是图标，而不是文本标签。ToolButton支持自动浮起。在自动浮起模式中，按钮只有在鼠标指向它的时候才绘制三维的框架。</p><p>3）控件设置选项：</p><p>（1）name：该控件对应源代码中的名称。</p><p>（2）text：工具按钮标签文本。</p><p>（3）font：设置工具按钮标签的字体。</p><p>（4）autoRaise：自动浮起是否生效。</p><p>（5）iconSet：提供显示在按钮上的图标的图标集。</p><p>（6）on：工具按钮是否为开。</p><p>（7）textLabel：工具按钮自动提示文本。</p><p>（8）usesTextLabel：自动提示文本textLabel是否工作，默认为false。</p><p>4）常用成员函数：</p><p>（1）QToolButton：：QToolButton（QWidget *parent，const char *name = 0）</p><p>构造一个名字为name，父对象为parent的ToolButton。</p><p>（2）QToolButton：：QToolButton（const QIconset &amp;iconSet，const QString &amp;textLabel，const QString &amp;grouptext，QObject *receiver，const char *slot，QToolBar *parent，const char *name = 0）</p><p>构造一个名称为name，父对象为parent（必须为QToolBar）的工具按钮。工具按钮将显示iconSet，工具提示为textLabel，状态条信息为grouptext，同时会将工具按钮链接到receiver对象的槽函数。</p><p>（3）QToolBButton：：QToolButton（ArrowType type，QWidget *parent，const char *name = 0）</p><p>此构造函数是把工具按钮构造成箭头按钮，type定义了箭头的方向，可用的值有LeftArrow、RightArrow、UpArrow、DownArrow。</p><p>（4）void QToolButton：：setAutoRaise（bool enable）</p><p>根据参数enable值设置按钮是否可自动浮起。</p><p>（5）void QToolButton：：setIcon（const QIconSet &amp;）</p><p>设置显示在工具按钮上的图标。</p><p>（6）void QToolButton：：setOn（bool enable）[虚槽]</p><p>设置按钮是否为开，enable等于true则设置为开，否则设置为关。</p><p>（7）void QToolButton：：setTextLabel（const QString &amp;）[槽]</p><p>设置按钮的提示标签。</p><p>（8）QString QToolButton：：textLabel（）const</p><p>返回按钮的提示标签。</p><h4 id="CommandLinkButton控件"><a href="#CommandLinkButton控件" class="headerlink" title="CommandLinkButton控件"></a>CommandLinkButton控件</h4><p>1）控件位置：Buttons-&gt;CommandLinkButton</p><p>2）控件介绍：命令链接按钮，继承自QPushButton，用于在互斥选项中选择一项，CommandLinkButton除带有正常的按钮上的文字描述文本外，默认情况下，它也将携带一个箭头图标，表明按下按钮将打开另一个窗口或页面。</p><p>3）控件属性设置选项：</p><p>（1）name：该控件对应源代码中的名称。</p><p>（2）text：该控件对应图形界面中所显示的标签。</p><p>（3）font：设置text的字体。</p><p>（4）enabled：该控件是否可用。</p><p>（5）description：一个描述性的标签，以配合按钮上的文字。</p><p>4）常用成员函数：</p><p>（1）QCommandLinkButton：：QCommandLinkButton（QWidget *parent = 0）</p><p>构造一个父对象为parent的命令链接按钮。</p><p>（2）QCommandLinkButton：：QCommandLinkButton（const QString &amp;text，QWidget *parent = 0）</p><p>构造一个父对象为parent、文本为text的命令链接按钮。</p><p>（3）QCommandLinkButton：：QCommandLinkButton（const QString &amp;text，const QString &amp;description，QWidget *parent = 0）</p><p>构造一个父对象为parent、文本为text和描述文本为description的命令链接按钮。</p><p>（4）void QButton：：clicked（）[信号]</p><p>当单击该按钮时，发射信号。</p><p>（5）void QButton：：pressed（）[信号]</p><p>当按下该按钮时，发射这个信号。</p><p>（6）void QButton：：released（）[信号]</p><p>当释放该按钮时，发射这个信号。</p><p>（7）void QButton：：setText（const QString &amp;）</p><p>设置改按钮上显示的文本。</p><p>（8）QString QButton：：text（）cosnt</p><p>返回按钮上显示的文本。</p><h4 id="ButtonBox控件"><a href="#ButtonBox控件" class="headerlink" title="ButtonBox控件"></a>ButtonBox控件</h4><p>1）控件位置：Buttons-&gt;ButtonBox</p><p>2）控件介绍：按钮键，室友QDialogButtonBox类包装成的。</p><p>3）控件属性设置选项：</p><p>（1）name：该控件对应源代码中的名称。</p><p>（2）font：设置text的字体。</p><p>（3）enabled：该控件是否可用。</p><p>（4）centerButtons：ButtonBox中的按钮是否居中布局，默认值为false。</p><p>（5）orientation：按钮布局方向，Qt提供QT：：Horizontal和QT：：Vertical两种。</p><p>（6）standardButtons：标准按钮集合。</p><p>4）常用成员函数：</p><p>（1）QDialogButtonBox：：QDialogButtonBox（QWidget *parent = 0）</p><p>构造一个按钮盒，父对象为parent。</p><p>（2）QDialogButtonBox：：QDialogButtonBox（QT：：Orientation orientation，QWidget *parent = 0）</p><p>构造一个按钮盒，父对象为parent，排列方向为orientation，并且包含buttons。</p><p>（3）QDialogButtonBox：：QDialogButtonBox（StandardButton buttons，QT：：Orientation orientation = QT：：Horizontal，QWidget *parent = 0）</p><p>构造一个按钮盒，父对象为parent，排列方向为orientation。</p><p>（4）void QDialogButtonBox：：accepted（）[signal]</p><p>当单击按钮盒里的定义为AcceptRole和YesRole的按钮时，发射信号。</p><p>（5）void QDialogButtonBox：：addButton（QAbstractButton *button，ButtonRole role）</p><p>向按钮盒里添加按钮button，定义按钮button的角色为role，如果role是无效的，则不添加按钮，如果按钮已添加，移除并在次添加为新角色。</p><p>（6）QPushButton *QDialogButtonBox：：addButton（StandarButton button）</p><p>向按钮盒中添加一个标准按钮button，并返回标准按钮。如果按钮无效，不添加，返回0.</p><p>（7）QPushButton *QDialogButtonBox：：addButton（const QString &amp;text，ButtonRole role）</p><p>创建一个按钮的文本为text，以指定角色添加到按钮盒，并返回相应的按钮，如果role是无效的，则不创建，返回0.</p><p>（8）void QDialogButtonBox：：clear（）</p><p>清空该按钮盒里的所有按钮。</p><p>（9）void QDialogButtonBox：：clicked（QAbstractButton *button）[signal]</p><p>当单击按钮盒里的按钮button时，发射这个信号。</p><p>（10）void QDialogButtonBox：：helpRequested（）[signal]</p><p>当单击按钮盒里的定义为HelpRole的按钮时，发射这个信号。</p><p>（11）void QDialogButtonBox：：rejected（）[signal]</p><p>当单击按钮盒里定义为RejectRole和NoRole的按钮时，发射这个信号。</p><p>（12）void QDialogButtonBox：：removeButton（QAbstractButton *button）</p><p>移除按钮盒里的按钮Button，但是不删除，设置它的父母为0.</p><h3 id="Item-Views"><a href="#Item-Views" class="headerlink" title="Item Views"></a>Item Views</h3><h4 id="ListView控件"><a href="#ListView控件" class="headerlink" title="ListView控件"></a>ListView控件</h4><p>  1.控件位置：Item Views-&gt;ListView</p><p>  2.控件介绍：列表视图，继承自QAbstractItemView。ListView是基于模型的列表/图标视图，为Qt的模型/视图结构提供了更灵活的方式。</p><p>  3.控件属性设置：</p><p>​    （1）name：该控件对应源代码中的名称。</p><p>​    （2）font：设置视图内字体。</p><p>​    （3）batchSize：如果将layoutMode设置为Batched，则这个属性保存批量处理的规格。</p><p>​    （4）layoutModel：项目的布局模式。</p><p>​    （5）modeColumn：模型中可见的类，默认情况下，置为0，表述模型中第一列可见。</p><p>​    （6）viewModel：保存该ListView的视图模型。</p><p>  4.常用成员函数：</p><p>​    （1）QListView：：QListView（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的ListView。</p><p>​    （2）void QListView：：currentChanged（const QModelIndex &amp;current，const QModelIndex &amp;previous）[virtual protected]</p><p>​    把current定位当前项目，previous是以前的项目。</p><p>​    （3）void QListView：：dataChanged（const QModelIndex &amp;topLeft，const QModelIndex &amp;bottomRight）[virtual protected]</p><p>​    更改模型中项目topLeft到bottomRight。</p><p>​    （4）QModelIndex QListView：：indexAt（const QPoint &amp;p）const [virtual]</p><p>​    返回坐标点p处项目的模型索引。</p><p>​    （5）void QListView：：rowsInserted（const QModelIndex &amp;parent，int start，int end）[virtual protected]</p><p>​    插入新行，新行的父母是parent，从start到end的所有项目。</p><p>​    （6）QModelIndexList QListView：：selectedIndexes（）const[virtual protected]</p><p>​    返回所有选中的非隐藏的项目的模型索引。</p><h4 id="TreeView控件"><a href="#TreeView控件" class="headerlink" title="TreeView控件"></a>TreeView控件</h4><p>  1.控件位置：Item View-&gt;TreeView</p><p>  2.控件介绍：树形视图，继承自QAbstractItemView，是基于模型的列表/图标视图，也是Qt模型/视图框架的一部分。</p><p>  3.控件属性设置选项：</p><p>​    （1）name：该控件对应源代码中的名称。</p><p>​    （2）font：设置该控件内所有文本的字体。</p><p>​    （3）sortingEnable：项目是否排序。</p><p>  4.常用成员函数：</p><p>​    （1）QTreeView：：QTreeView（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的TreeView。</p><p>​    （2）void QTreeView：：collapse（const QModena &amp;index）[slot]</p><p>​    折叠模型索引为index的项目</p><p>​    （3）void QTreeView：：collapseAll（）[slot]</p><p>​    折叠所有项目</p><p>​    （4）int QTreeView：：columnAt（int x）const</p><p>​    返回x坐标处的列。</p><p>​    （5）void QTreeView：：columnCountChanged（int oldCount，int newCount）[protected slot]</p><p>​    通知树形视图中的列数，从oldCount改变到newCount。</p><p>​    （6）void QTreeView：：currentChanged（const QModelIndex &amp;current，const QModelIndex &amp;previous）[virtual protected]</p><p>​    把current定为当前项目，previous是以前的当前项目</p><p>​    （7）void QTreeView：：dataChanged（const QModelIndex &amp;topLeft，const QModelIndex &amp;bottomRight）[virtual]</p><p>​    更改模型中项目topLeft到bottomRight。</p><p>​    （8）void QTreeView：：drawBranches（QPainter *painter，const QRect &amp;rect，const QModelIndex &amp;index）const [virtual protected[</p><p>​    在项目index的同一行，用painter绘制指定的rect矩形分支。</p><p>​    （9）void QTreeView：：drawRow（QPainter *painter，const QStyleOptionViewItem &amp;option，const QModelIndex &amp;index）const [virtual protected]</p><p>​    用painter绘制新行，新行包含模型索引 为index的项目，option是如何显示项目。</p><p>​    （10）void QTreeView：：drawTree（QPainter *painter，const QRegion &amp;region）const [protected]</p><p>​    用painter在区域region绘制树</p><p>​    （11）void QTreeView：：expand（const QModelIndex &amp;index）[slot]</p><p>​    展开模型索引为index的项目。</p><p>​    （12）void QTreeView：：expandAll（）[slot]</p><p>​    展开所有的项目</p><p>​    （13）void QTreeView：：expandToDepth(int depth) [slot]</p><p>​    展开树形视图中的项目，深度为depth</p><p>​    （14）QHeaderView *QTreeView：：header（）const</p><p>​    返回该树形视图的header</p><p>​    （15）QModelIndex QTreeView：：indexAbove（const QModelIndex &amp;index）const</p><p>​    返回模型索引index的上一个索引</p><p>​    （16）QModelIndex QTreeView：：indexAt（const QPoint &amp;point）const [virtual]</p><p>​    返回点point处项目的模型索引</p><p>​    （17）QModelIndex QTreeView：：indexBelow（const QModelIndex &amp;index）const</p><p>​    返回模型索引index的下一个索引</p><p>​    （18）bool QTreeView：：isExpanded（const QModelIndex &amp;index）const</p><p>​    如果模型索引index处的项目是展开着的，返回true，否则返回false</p><p>​    （19）void QTreeV：：rowsInserted（const QModelIndex &amp;parent，int start，int end）[virtual protected]</p><p>​    插入新行，新行的父母是parent，包括从start到end的所有项目。</p><p>​    （20）void QTreeView：：rowsRemoved（const QModelIndex &amp;parent，int start，int end）[protected slot]</p><p>​    删除行，行的父母是parent，包括从start到end的所有项目</p><p>​    （21）void QTreeView：：selectAll（）[virtual]</p><p>​    设置所有的项目都是选择状态</p><p>​    （22）QModelIndexList QTreeView：：selectedIndexes（）const [virtual protected]</p><p>​    返回所有选中和非隐藏的项目的模型索引</p><p>​    （23）void QTreeView：：setHeader（QHeaderView *header）</p><p>​    设置该TreeView的标题为header</p><p>​    （24）void QTreeView：：sortByColumn（int column，QT：：SortOrder order）</p><p>​    对列column按order进行排序</p><h4 id="TableView控件"><a href="#TableView控件" class="headerlink" title="TableView控件"></a>TableView控件</h4><p>  1.控件位置：Item View-&gt;TableView</p><p>  2.控件介绍：表格视图，是一个模型/视图结构的表视图实现，用来显示模型的项目。它提供了QTable类提供的标准表格。是Qt的模型/视图框架的一部分。由QAbstractItemView类定义的接口来实现，使其能够显示由QAbstractItemModel类派生的模型提供的数据。</p><p>  3.控件属性设置选项：</p><p>​    （1）name：该控件对应源代码中的名称</p><p>​    （2）font：设置表格内部的字体</p><p>​    （3）cornerButtonEnabled：左上角的按钮是否有用</p><p>​    （4）gridStyle：表格的格式</p><p>​    （5）showGrid：是否显示网格，值为true，显示，否则不显示</p><p>​    （6）sortingEnabled：是否对项目排序</p><p>  4.常用成员函数</p><p>​    （1）QTableView：：QTableView（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的TableView</p><p>​    （2）void QTableView：：clearSpans（）</p><p>​    删除该TableView中的所有行和列的跨度</p><p>​    （3）int QTableView：：columnAt（int x）const</p><p>​    返回坐标x处的列，如果坐标处没有项目则返回-1</p><p>​    （4）int QTableView：：columnSpan（int row，intcolumn）const</p><p>​    返回行row、列column处的行跨度</p><p>​    （5）void QTableView：：currentChanged（const QModelIndex &amp;current，const QModelIndex &amp;previous）[virtual protected]</p><p>​    把current指定为当前项目，previous是以前的项目</p><p>​    （6）QHeaderView *QTableView：：horizontalHeader（）const</p><p>​    返回该TableView的水平标题</p><p>​    （7）QModelIndex QTableView：：indexAt（const QPoint *pos）const [virtual]</p><p>​    返回点pos处项目的模型索引</p><p>​    （8）int QTableView：：rowAt（int y）const</p><p>​    返回坐标y处的行，如果坐标处没有项目则返回-1</p><p>​    （9）int QTableView：：rowSpan（int row，int column）const</p><p>​    返回行row、列column处的列跨度</p><p>​    （10）void QTableView：：selectcolumn（int column）[slot]</p><p>​    设置列column为选中状态</p><p>​    （11）void QTableView：：selectRow（int row）[slot]</p><p>​    设置行row为选中状态</p><p>​    （12）QModelIndexList QTableView：：selectedIndexes（）const [virtual protected]</p><p>​    返回所有选中和非隐藏的项目的模型索引</p><p>​    （13）void QTableView：：setHorizontalHeader（QHeaderView *header）</p><p>​    设置该TableView的水平标题为header</p><p>​    （14）void QTableView：：setSpan（int row，int column，int rowSpanCount，int columnCount）</p><p>​    设置行row、列column处的行跨度为rowSpanCount、列跨度为columnSpanCount</p><p>​    （15）void QTableView：：setVerticalHeader（QHeaderView *header）</p><p>​    设置该TableView的垂直标题为header</p><p>​    （16）void QTableView：：showColumn（int column）[slot]</p><p>​    显示列column</p><p>​    （17）void QTableView：：showRow（int row）[slot]</p><p>​    显示行row</p><p>​    （18）QHeaderView *QTableView：：verticalHeader（）const</p><p>​    返回TableView的垂直标题</p><h4 id="ColumnView控件"><a href="#ColumnView控件" class="headerlink" title="ColumnView控件"></a>ColumnView控件</h4><p>  1.控件位置：Item View-&gt;ColumnView<br>  2.控件介绍：列视图<br>  3.控件属性设置选项：</p><p>​    （1）name：该控件对应源代码中的名字<br>​    （2）font：设置表格内部的字体</p><p>  4.常用成员函数</p><p>​    （1）QColumnView：：QColumnView（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的ColumnView</p><p>​    （2）QAbstractItemView * QColumnView：：createColumn（const QModelIndex *index）[virtual protected]</p><p>​    index是视图的根模型索引，返回新的视图</p><p>​    （3）void QColumnView：：currentChanged（const QModelIndex &amp;current，const QModelIndex &amp;previous）[virtual protected]</p><p>​    把current指定为当前项目，previous是以前的当前项目</p><p>​    （4）QModelIndex QColumnView：：indexAt（cosnt QPoint &amp;point）const [virtual]</p><p>​    返回点pos处项目的索引模型</p><p>​    （5）QWidget *QColumnView：：previewWidget（）const</p><p>​    返回预览组件，如果没有则返回0</p><p>​    （6）void QColumnView：：rowsInserted（const QModelIndex &amp;parent，int start，int end）[virtual protected]</p><p>​    插入新行，新行的父母是parent包括从start到end的所有项目</p><p>​    （7）void QColumnView：：selectAll（）[virtual]</p><p>​    设置该ColumnView中的所有项目为选中状态</p><p>​    （8）void QColumnView：：setPreviewWidget（QWidget *widget）</p><p>​    设置widget为该columnView的预览组件。</p><h3 id="Item-Widgets"><a href="#Item-Widgets" class="headerlink" title="Item Widgets"></a>Item Widgets</h3><h4 id="ListWidget控件"><a href="#ListWidget控件" class="headerlink" title="ListWidget控件"></a>ListWidget控件</h4><p>  1.控件位置：Item Widget-&gt;ListWidget<br>  2.控件介绍：ListWidget继承自QListView类，基于Item的列表控件。<br>  3.控件属性设置选项：</p><p>​    （1）name：该控件对应源代码内的名称<br>​    （2）font：设置该表格内部的字体<br>​    （3）count：保持项目的数目<br>​    （4）currentRow：保持当前项目的行<br>​    （5）sortingEnabled：是否对item排序</p><p>  4.常用成员函数：</p><p>​    （1）QListWidget：：QListWidget（QWidget *parent = 0）</p><p>​    构造父对象为parent的ListWidget</p><p>​    （2）void QListWidget：：addItem（QListWidgetItem *item）</p><p>​    添加项目item</p><p>​    （3）void QListWidget：：addItem（const QString &amp;label）</p><p>​    添加一个新的项目，在新添加的项目中添加label标签</p><p>​    （4）void QListWidget：：addItems（const QStringList &amp;labels）</p><p>​    添加一列项目</p><p>​    （5）void QListWidget：：clear（）[slot]</p><p>​    清除该ListWidget中的所有项目</p><p>​    （6）QListWidgetItem *QListWidget：：currentItem（）const</p><p>​    返回当前活动的项目</p><p>​    （7）void QListWidget：：editItem（QListWidgetItem *item）</p><p>​    如果项目item是可编辑的，开始编辑项目item</p><p>​    （8）QList&lt;QListWidgetItem *&gt;QListWidget：：findItems（const QString &amp;text，Qt：：MatchFlags flags）const</p><p>​    查找匹配字符串text的项目，并返回查找结果</p><p>​    （9）void QListWidget：：insertItem（int row，QListWidgetItem * item）</p><p>​    在行row处插入项目item</p><p>​    （10）void QListWidget：：insertItem（int row，const QString &amp;label）</p><p>​    这是一个重载函数，功能同（9），在行row处插入标签为label的新项目</p><p>​    （11）void QListWidget：：insertItem（int row，const QStringList &amp;labels）</p><p>​    在行row处插入一列项目</p><p>​    （12）QListWidgetItem *QListWidget：：item（int row）const</p><p>​    返回行row处的项目，如果行row处没有项目则返回0</p><p>​    （13）QListWidgetItem *QListWidget：：itemAt（const QPoint &amp;p）const</p><p>​    返回点p处的项目</p><p>​    （14）QListWidgetItem *QListWidget：：itemAt（int row，int y）const</p><p>​    返回坐标（x，y）处的项目</p><p>​    （15）QWidget *QListWidget：：itemWidget（QListWidgetItem *item）const</p><p>​    返回项目item处显示的控件</p><p>​    （16）QListWidgetItem *QListWidget：：takeItem（int row）</p><p>​    移除行row处的项目，并返回项目控件</p><p>​    （17）void QListWidget：：removeItemWidget（QListWidgetItem *item）</p><p>​    移除项目item处的控件</p><p>​    （18）int QListWidget：：row（const QListWidgetItem *item）cosnt</p><p>​    返回项目item所在的行</p><p>​    （19）QList&lt;QListWidgetItem*&gt; QListWidget：：selectedItems（）const</p><p>​    返回所有被选中的项目的控件</p><p>​    （20）void QListWidget：：setcurrentItem（QListWidgetItem *item）</p><p>​    设置项目item为当前项目</p><p>​    （21）void QListWidget：：setItemWidget（QListWidgetItem *item，QWidget *widget）</p><p>​    设置控件widget为项目item的显示控件</p><p>​    （22）void QListWidget：：setItemWidget（QListWidgetItem *item，QWidget *widget）</p><p>​    （23）void QListWidget：：sortItems（Qt：：SortOrder order = Qt：：AscendingOrder）</p><p>​    把项目按照order进行排序</p><h4 id="TreeWidget控件"><a href="#TreeWidget控件" class="headerlink" title="TreeWidget控件"></a>TreeWidget控件</h4><p>  1.控件位置：Item Widget-&gt;TreeWidget<br>  2.控件介绍：树形单元控件，继承自QTreeView类，是树形视图使用预定义的模型，他也是基于模型/视图结构的控件，为方便开发人员使用树形视图，可以使用这个控件来创建简单地树形结构列表<br>  3.控件属性设置选项：</p><p>​    （1）name：同上<br>​    （2）font：同上<br>​    （3）columnCount：保存该TreeWidget的列数</p><p>  4.常用成员函数</p><p>​    （1）QTreeWidget：：QTreeWidget（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的TreeWidget</p><p>​    （2）void QTreeWidget：：addTopLevelItem（QTreeWidgetItem * item）</p><p>​    在该TreeWidget中追加item为顶级项目</p><p>​    （3）void QTreeWidget：：addTopLevelItems（const QList&lt;QTreeWidgetItem*&gt; &amp;items）</p><p>​    把items中的项目作为顶级项目追加到该TreeWidget中</p><p>​    （4）void QTreeWidget：：clear（）[slot]</p><p>​    清除该TreeWidget中的所有项目</p><p>​    （5）void QTreeWidget：：collapseItem（const QTreeWidgetItem *item）[slot]</p><p>​    折叠项目item</p><p>​    （6）int QTreeWidget：：currentColumn（）const</p><p>​    返回当前活动列</p><p>​    （7）QTreeWidgetItem *QTreeWidget：：currentItem（）const</p><p>​    返回当前活动项目</p><p>​    （8）void QTreeWidget：：editItem（QTreeWidgetItem *item，int column = 0）</p><p>​    如果列column的item是可编辑的，开始编辑</p><p>​    （9）void QTreeWidget：：expandItem（const QTreeWidgetItem *item）[slot]</p><p>​    展开项目</p><p>​    （10）QList&lt;QTreeWidgetItem*&gt; QTreeWidget：：findItems（const QString &amp;text，Qt：：MatchFlags flags，int column = 0）const</p><p>​    查找匹配字符串的text的项目，并返回查找结果</p><p>​    （11）QTreeWidgetItem *QTreeWidget：：headerItem（）const</p><p>​    返回头项目</p><p>​    （12）QModelIndex QTreeWidget：：indexFromItem（QTreeWidgetItem *item，int column = 0）const [protected]</p><p>​    返回列column的项目item模型索引</p><p>​    （13）int QTreeWidget：：indexOfTopLevelItem（QTreeWidgetItem *item）const</p><p>​    返回顶级项目item的模型索引，如果item不存在返回-1</p><p>​    （14）int QTreeWidget：：sortColumn（）const<br>​    返回排序的列</p><p>​    （15）void QTreeWidget：：sortItems（int column，Qt：：SortOrder order）</p><p>​    对列column的项目按照order进行排序</p><p>​    （16）QTreeWidgetItem *QTreeWidget：：itemAbove（const QTreeWidgetItem *item）const</p><p>​    返回item的上一个项目</p><p>​    （17）QTreeWidgetItem *QTreeWidget：：itemAt（const QPoint &amp;p） const</p><p>​    返回点p处的项目</p><p>​    （18）QTreeWidgetItem *QTreeWidget：：itemAt（int x，int y）const</p><p>​    返回坐标（x，y）处的项目</p><p>​    （19）void QTreeWidget：：setItemWidget（QTreeWidgetItem *item，int column，QWidget *widget）</p><p>​    设置控件widget为项目item的显示控件，项目item在列column中</p><p>​    （20）QTreeWidgetItem *QTreeWidget：：itemBelow（const QTreeWidgetItem *item）const</p><p>​    返回item的下一个项目</p><p>​    （21）QWidget *QTreeWidget：：itemWidget（QTreeWidgetItem *item，int column）const</p><p>​    返回列column中的项目item显示控件</p><p>​    （22）void QTreeWidget：：removeItemWidget（QTreeWidgetItem *item，int column）</p><p>​    移除列column中的项目item的显示控件</p><p>​    （23）QList&lt;QTreeWidgetItem *&gt; QTreeWidget：：selectItems（）const</p><p>​    返回所有选中状态的项目</p><p>​    （24）void QTreeWidget：：setCurrentItem（QTreeWidgetItem *item）</p><p>​    设置item为当前项目</p><p>​    （25）void QTreeWidget：：setCurrentItem（QTreeWidgetItem *item，int column）</p><p>​    设置列column的项目item为当前项目</p><p>​    （26）void QTreeWidget；：setHeaderItem（QTreeWidgetItem *item）</p><p>​    设置item为该TreeWidget的头项目</p><p>​    （27）void QTreeWidget：：setHeaderLabel（const QString &amp;label）</p><p>​    设置label为头标题</p><p>​    （28）QTreeWidgetItem *QTreeWidget：：topLevelItem（int index）cosnt</p><p>​    返回所有index的顶级项目</p><h4 id="TableWidget控件"><a href="#TableWidget控件" class="headerlink" title="TableWidget控件"></a>TableWidget控件</h4><p>  1.控件位置：Item Widget-&gt;Table Widget<br>  2.控件介绍：表格单元控件<br>  3.控件属性设置选项：</p><p>​    （1）name：同上<br>​    （2）font：同上<br>​    （3）columnCount：保存列的数目<br>​    （4）rowCount：保存行的数目</p><p>​    4.常用成员函数</p><p>​    （1）QTableWidget：：QTableWidget（QWidget * parent = 0）</p><p>​    构造一个父对象为parent的TableWidget</p><p>​    （2）QTableWidget：：QTableWidget（int rows，int columns，QWidget *parent = 0）</p><p>​    构造一个rows行，columns列，父对象为parent的TableWidget控件</p><p>​    （3）QWidget *QTableWidget：：cellWidget（int row，int column）const</p><p>​    返回行row，列column的单元格处的控件</p><p>​    （4）void QTableWidget：：clear（）[slot]</p><p>​    删除该TreeWidget中的所有项目</p><p>​    （5）void QTableWidget：：clearContents（）[slot]</p><p>​    删除该TreeWidget中除了header外的所有项目</p><p>​    （6）int QTableWidget：：column（const QTableWidgetItem *item）const</p><p>​    返回项目item所在的列</p><p>​    （7）int QTableWidget：：currentColumn（）const</p><p>​    返回当前活动的列</p><p>​    （8）QTableWidgetItem *QTableWidget：：currentItem（）const</p><p>​    返回当前活动的项目</p><p>​    （9）int QTableWidget：：currentRow（）const</p><p>​    返回当前活动的行</p><p>​    （10）void QTableWidget：：editItem（QTableWidgetItem *item）</p><p>​    如果item是可编辑的，开始编辑item</p><p>​    （11）QList&lt;QTableWidgetItem *&gt; QTableWidget：：findItems（const QString &amp;text，Qt：：MatchFlags flags）const</p><p>​    查找匹配字符串text的项目，并返回查找结果</p><p>​    （12）void QTableWidget：：insertColumn（int column）[slot]</p><p>​    在列column处插入新列</p><p>​    （13）void QTableWidget：：insertRow（int row）[slot]</p><p>​    在行row处插入新行</p><p>​    （14）QTableWidgetItem *QTableWidget：：item（int row，int column）const</p><p>​    返回行row、列column处的项目</p><p>​    （15）QTableWidgetItem *QTableWidget：：itemAt（const QPoint &amp;point）const</p><p>​    返回点point处的项目</p><p>​    （16）QTableWidgetItem *QTableWidget：：itemAt（int ax，int ay）const</p><p>​    返回坐标（ax，ay）处的项目</p><p>​    （17）void QTableWidget：：removeCellWidget（int row，int column）</p><p>​    移除行row、列column单元格处的显示控件</p><p>​    （18）void QTableWidget：：removeColumn（int column）[slot]</p><p>​    移除列column</p><p>​    （19）void QTableWidget：：removerRow（int row）[slot]</p><p>​    移除行row</p><p>​    （20）int QTableWidget：：row（const QTableWidgetItem *item）cosnt</p><p>​    返回item的行</p><p>​    （21）QList&lt;QTableWidgetItem *&gt; QTableWidget：：selectedItems（）</p><p>​    返回所有选中状态的项目</p><p>​    （22）void QTableWidget：：setCellWidget（int row，int column，QWidget *widget）</p><p>​    设置行row、列column处的显示控件为widget。</p><p>​    （23）void QTableWidget：：setCurrentCell（int row，int column）</p><p>​    设置行row，列column处的单元格为当前活动单元格</p><p>​    （24）void QTableWidget：：setCurrentItem（QTableWidgetItem *item）</p><p>​    设置项目item为当前活动项目</p><p>​    （25）void QTableWidget：：setHorizontalHeaderItem（int column，QTableWidgetItem *item）</p><p>​    设置项目item为列column的水平头项目，功能同setVerticalHeaderItem（）</p><p>​    （26）void QTableWidget：：setHorizontalHeaderLabels（const QStringList *labels）</p><p>​    设置水平标题为labels，功能同setVerticalHeaderLabels（）</p><p>​    （27）void QTableWidget：：setItem（int row，int column，QTableWidgetItem *item）</p><p>​    设置行row、列column的单元格的项目为item</p><p>​    （28）void QTableWidget：：sortItems（int column，Qt：：SortOrder order = Qt：：AscendingOrder）</p><p>​    对列column按照order进行排序</p><p>​    （29）QTableWidgetItem *QTableWidget：：takeHorizonalHeaderItem（int column）</p><p>​    移除列column的水平头项目，功能同takeVerticalHeaderItem（）</p><p>​    （30）QTableWidgetItem *QTableWidget：：takeItem（int row，int column）</p><p>​    移除行row、列column单元格处的项目</p><p>​    （31）QTableWidgetItem *QTableWidget：：verticalHeaderItem（int row）const</p><p>​    返回行row的垂直头项目</p><h3 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h3><h4 id="GroupBox控件"><a href="#GroupBox控件" class="headerlink" title="GroupBox控件"></a>GroupBox控件</h4><p>  1.控件位置：Containers-&gt;GroupBox</p><p>  2.控件介绍：GroupBox好处就是用户可以比较清晰地了解程序的界面，我们可以把功能相关的控件放到一个GroupBox中。</p><p>  3.控件属性设置选项：</p><p>​    （1）name：该控件对应源代码中的名称</p><p>​    （2）title：该控件对应图形界面中所显示的名称</p><p>​    （3）font：设置title的字体</p><h4 id="ScrollArea控件"><a href="#ScrollArea控件" class="headerlink" title="ScrollArea控件"></a>ScrollArea控件</h4><p>  1.控件位置：Containers-&gt;ScrollArea</p><p>  2.控件介绍：用来显示子控件的内容的框架，如果子控件的尺寸超过了框架的大小，可以使用滚动条，方便查看整个子控件</p><p>  3.控件属性设置选项：</p><p>​    （1）neme：同上</p><p>​    （2）font：设置文本框的字体</p><p>  4.常用成员函数</p><p>​    （1）QScrollArea：：QScrollArea（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的ScrollArea</p><p>​    （2）void QScrollArea：：setWidget（QWidget *widget）</p><p>​    设置控件widget为该ScrollArea的子控件</p><p>​    （3）QWidget *SCrollArea：：takeWidget（）</p><p>​    删除该ScrollArea的子控件</p><p>​    （4）QWidget *QScrollArea：：widget（）const</p><p>​    返回该ScrollArea的子控件</p><h4 id="ToolBox控件"><a href="#ToolBox控件" class="headerlink" title="ToolBox控件"></a>ToolBox控件</h4><p>  1.控件位置：Containers-&gt;ToolBox</p><p>  2.控件介绍：ToolBox提供了一系列的页和隔间，就像Qt Creator中的工具箱一样。</p><p>  3.控件属性设置选项</p><p>​    （1）name：同上</p><p>​    （2）font：同上</p><p>​    （3）currentIndex：当前活动页的索引</p><p>​    （4）itemLabel：当前活动页的标签</p><p>​    （5）itemName：当前活动页的名称</p><p>​    （6）itemBackgroundModel：当前活动页的背景模式</p><p>  4.常用成员函数</p><p>​    （1）QToolBox：：QToolBox（QWidget *parent = 0，const char *name = 0，QFlags f = 0）</p><p>​    构造一个名称为name，父对象为parent和标志位f的ToolBox</p><p>​    （2）int QToolBox（QWidget *item，const QIconSet &amp;iconSet，const QString &amp;label）</p><p>​    增加一个item到ToolBox的底部，新增加的item的标签的文本是label，标签的图标是iconSet</p><p>​    （3）int QToolBox（QWidget *item，const QString &amp;label）</p><p>​    增加一个item到ToolBox底部，新增加的item的标签文本是label</p><p>​    （4）int ToolBox：：count（）const</p><p>​    返回该工具箱中item数目</p><p>​    （5）int ToolBox：：currentIndex（）const</p><p>​    返回当前活动item的索引</p><p>​    （6）QWidget *QToolBox：：currentItem（）const</p><p>​    返回当前活动item，如果该ToolBox为空，返回0</p><p>​    （7）int ToolBox：：indexof（QWidget *item）const</p><p>​    返回item的索引</p><p>​    （8）int QToolBox：：insertItem（int index，QWidget *item，const QIconSet &amp;iconSet，const QString &amp;label）</p><p>​    在索引index处插入一个新的项目，项目是item，标签图标是iconSet，标签文本时label，返回插入item的索引</p><p>​    （9）int QToolBox：：insertItem（int index，QWidget *item，const QString &amp;label）</p><p>​    在索引index处插入一个新的项目，项目的名称是item，标签文本是label，返回插入item的索引。</p><p>​    （10）QWidget *QToolBox：：item（int index）const</p><p>​    返回索引为index位置的item</p><p>​    （11）QString QToolBox：：itemLabel（int index）const</p><p>​    返回索引为index位置的标签</p><p>​    （12）int QToolBox：：RemoveItem（QWidget *item）</p><p>​    删除ToolBox中的item的项目，删除成功后返回item的索引，否则返回-1</p><p>​    （13）void QToolBox：：setCurrentIndex（int index）</p><p>​    设置索引为index位置的项目为当前活动项目</p><p>​    （14）void QToolBox：：setCurrentIndex（QWidget *item）</p><p>​    设置索引item为当前活动的项目</p><p>​    （15）void QToolBox：：setItemLabel（int index，const QString &amp;label）</p><p>​    设置label为索引index位置的项目的标签文本</p><h4 id="TabWidget控件"><a href="#TabWidget控件" class="headerlink" title="TabWidget控件"></a>TabWidget控件</h4><p>  1.控件位置：Containers-&gt;TabWidget</p><p>  2.控件介绍：切换卡控件顶部或底部有一个标签选项栏，每个标签选项都有一个页面，选择哪个页面，只需单击对应的标签即可，或按指定ALT+字母快捷键组合即可。</p><p>  3.控件属性设置选项</p><p>​    （1）name：同上</p><p>​    （2）currentPage：当前活动的页面</p><p>​    （3）margin：页面边框的空白宽度，默认是0</p><p>​    （4）tabShap：标签选项的模式</p><p>​    （5）pageName：当前活动页的名称</p><p>​    （6）pageTitle：当前活动也得标签文本</p><p>  4.常用成员函数</p><p>​    （1）QTabWidget：：QTabWidget（QWidget *parent = 0，const char *name = 0，WFlags f = 0）</p><p>​    构造一个名称为name、父对象为parent和标记为f的TabWidget</p><p>​    （2）void QTabWidget：：addTab（QWidget *child，const QString &amp;label）[virtual]</p><p>​    增加子页到该TabWidget，子页控件是child，子页标签文本是label</p><p>​    （3）void QTabWidget：：addTab（QWidget *child，const QIconSet &amp;iconset，const QString &amp;label）[virtual]</p><p>​    这是一个重载成员函数，功能同函数2，只是增加了一个iconset，iconset是图标集</p><p>​    （4）QString QTabWidget：：tabLabel（QWidget *w）const</p><p>​    返回索引index处子页的选项标签文本</p><p>​    （5）void QTabWidget：：changeTab（QWidget *w，const QString &amp;label）</p><p>​    更改子页w的标签文本为label</p><p>​    （6）void QTabWidget：：changeTab（QWidget *w，const QIconSet &amp;iconset，const QString &amp;label）</p><p>​    更改子页w的图标为iconset，和更改标签文本为label</p><p>​    （7）int QTabWidget：：count（）const</p><p>​    返回该TabWidget中子页的数目</p><p>​    （8）QWidget *QTabWidget：：currentPage（）const</p><p>​    返回当前活动子页</p><p>​    （9）int QTabWidget：：currentPageIndex（）const</p><p>​    返回当前活动子页的索引</p><p>​    （10）int QTabWidget：：indexOf（QWidget *w）const</p><p>​    返回子页w的索引</p><p>​    （11）void QTabWidget：：insertTab（QWidget *child，const QString &amp;label，int index = -1）[virtual]</p><p>​    在索引index处插入新的子页，子页控件是child，子页标签文本是label。注意：在插入新的子页时要确保插入的子页名与标签文本与TabWidget中的所有子页不同，如果指定index就是在指定的位置插入，否则就和简单地添加一样。</p><p>​    （12）void QTabWidget：：insetTab（QWidget *child，const QIconSet &amp;iconset，const QString &amp;label，int index = -1）[virtual]</p><p>​    在索引index处插入新的子页，子页控件是child，子页标签文本是label，子页图标为iconset</p><p>​    （13）QString QTabWidget：：label（int index）const</p><p>​    返回索引index处子页的选项标签</p><p>​    （14）QWidget *QTabWidget：：page（int index）const</p><p>​    返回索引index处子页</p><p>​    （15）void QTabWidget：：removePage（QWidget *w）[virtual slot]</p><p>​    删除子页w</p><p>​    （16）void QTabWidget：：setCurrentPage（int index）[slot]</p><p>​    设置索引index处子页为当前活动页</p><p>​    （17）void QTabWidget：：setTabLabel（QWidget *w，const QString &amp;label）</p><p>​    设置子页w的标签文本为label</p><h4 id="StackedWidget控件"><a href="#StackedWidget控件" class="headerlink" title="StackedWidget控件"></a>StackedWidget控件</h4><p>​    1.控件位置：Containers-&gt;StackedWidget</p><p>​    2.控件介绍：Qt提供了这样一个控件栈，可以使开发人员使用栈管理控件，像用栈管理其他数据类型一样简单。控件栈只显示栈顶的控件，开发人员可以使用raiseWidget（）函数把栈中任何其他控件移到栈顶，从而实现控件之间的切换。</p><p>​    3.控件属性设置选项：</p><p>​      （1）name：同上</p><p>​      （2）currentPage：当前活动的页面</p><p>​      （3）pageName：当前活动页的名称</p><p>​      （4）font：设置该控件内部文本的字体</p><p>​    4.常用成员函数：</p><p>​      （1）QWidgetStack：：QWidgetStack（QWidget *parent = 0，const char * name = 0）</p><p>​      构造一个名称为name，父对象为parent的WidgetStack</p><p>​      （2）int QWidgetStack：：addWidget（QWidget *w，int id = -1）</p><p>​      把控件w添加到该控件栈中，标识为id</p><p>​      （3）int QWidgetStack：：id（QWidget *w）const</p><p>​      返回控件w的标识</p><p>​      （4）void QWidgetStack：：raiseWidget（int id）[slot]</p><p>​      把标识为id的控件升到该控件栈的栈顶</p><p>​      （5）void QWidgetStack：：raiseWidget（QWidget *w）[slot]</p><p>​      把控件w升到该控件的栈顶</p><p>​      （6）void QWidgetStack：：removeWidget（QWidget *w）</p><p>​      把控件w从该控件栈中删除</p><p>​      （7）QWidget *QWidgetStack：：widget（int id）const</p><p>​      返回标识为id的控件</p><h4 id="Frame控件"><a href="#Frame控件" class="headerlink" title="Frame控件"></a>Frame控件</h4><p>​    1.控件位置：Containers-&gt;Frame</p><p>​    2.控件介绍：框架控件用来存放其他控件，也可用于装饰，它一般用来作为更加复杂容器的基础。也可以用在form中作为占用控件。</p><p>​    3.控件属性设置选项：</p><p>​      （1）name：同上</p><p>​      （2）framesShape：框架外形格式</p><p>​      （3）framesShadow：框架阴影格式</p><p>​      （4）frameWidth：框架的宽度（只读）</p><p>​      （5）LineWidth：线宽</p><p>​    4.常用成员函数</p><p>​      （1）QFrame：：QFrame（QWidget *parent = 0，const char *name = 0，WFlags f = 0）</p><p>​      构造一个框架风格为NoFrame并且1像素框架宽度的框架窗口部件，如：QFrame *f = new（）；</p><h4 id="Widget控件"><a href="#Widget控件" class="headerlink" title="Widget控件"></a>Widget控件</h4><p>​    1.控件位置：Containers-&gt;Widget</p><p>​    2.控件介绍：Widget组件在创建时是不可见的，他可以包含子控件，在删除该Widget时，子控件也一起删除。</p><p>​    3.控件属性设置选项：</p><p>​      （1）name：同上</p><p>​      （2）font：设置表盘上的字体</p><p>​      （3）cursor：设置鼠标光标样式</p><p>​    4.常用成员函数：</p><p>​      （1）QWidget：：QWidget（QWidget *parent = 0，const char *name = 0，WFlags f = 0）</p><p>​      构造一个名称为name，父对象为parent的Widget</p><p>​      （2）QWidget *QWidget：：childAt（int x，int y，bool includeThis = FALSE）const</p><p>​      返回该Widget坐标系统中像素位置（x，y）处的可视的子窗口部件</p><p>​      （3）QWidget *QWidget：：childAt（const QPoint &amp;p，bool includeThis = FALSE）const</p><p>​      返回该Widget坐标系统位置p处的可视的子窗口部件</p><p>​      （4）void QWidget：：drawText（int x，int y，const QString &amp;str）</p><p>​      在该Widget坐标系统中像素位置（x，y）处绘制字符串str</p><p>​      （5）void QWidget：：drawText（const QPoint &amp;p，const QString &amp;str）</p><p>​      在该Widget坐标系统中位置p处绘制字符串str</p><h4 id="MdiArea控件"><a href="#MdiArea控件" class="headerlink" title="MdiArea控件"></a>MdiArea控件</h4><p>​    1.控件位置：Containers-&gt;MdiArea<br>​    2.控件介绍：MdiArea控件中文称作“MDI窗口显示区”，MDI是Multiple Document Interface的简称，中文意思是多文档界面，主要适用于完成一项工作时需要用到多个文件。QMainWindow是SDI（Signal Document Interface，单文档界面）每个开启的文件占据一个视窗，主要适用于所有工作没有太多文件参与的情况。<br>​    3.控件属性设置选项；</p><p>​      （1）name：同上<br>​      （2）font：同上<br>​      （3）viewMode：设置视图模式Qt提供TabbedView和SubWindowView两种选择<br>​      （4）documentMode：保存的标签栏在选项卡视图模式是否设置为文件的模式，默认为false。<br>​      （5）tabShape：（当viewMode是TabbedView时）设置该MdiArea的标签形式Qt提供两种选择：Rounded和Triangular。<br>​      （6）tabPosition：（当viewMode是TabbedView时）设置标签所在方向<br>​      （7）activeSubWindowName：子窗口的名称<br>​      （8）activeSubWindowTitle：子窗口的标签</p><p>​    4.常用成员函数</p><p>​      （1）QMdiArea：：QMdiArea（QWidget *parent = 0）</p><p>​      构造一个父对象为parent的MdiArea</p><p>​      （2）void QMdiArea：：activateNextSubWindow（）[slot]</p><p>​      激活下一个窗口</p><p>​      （3）void QMdiArea：：activatePreviousSubWindow（）[slot]</p><p>​      激活上一个窗口</p><p>​      （4）QMdiSubWindow *QMdiArea：：activateSubWindow（）const</p><p>​      返回当前活动子窗口，如果当前没有活动子窗口，返回0</p><p>​      （5）QMdiSubWindow *QMdiArea：：addSubWindow（QWidget *widget，Qt：：WindowFlags windowFlags = 0）</p><p>​      添加一个新的子窗口部件</p><p>​      （6）void QMdiArea：：closeActiveSubWindow（）[slot]</p><p>​      关闭当前活动子窗口</p><p>​      （7）void QMdiArea：：closeAllSubWindow（）[slot]</p><p>​      关闭所有子窗口</p><p>​      （8）QMdiSubWindow *QMdiArea：：currentSubWindow（）const</p><p>​      函数功能同activeSubWindow（0</p><p>​      （9）void QMdiArea：：removeSubWindow（QWidget *widget）</p><p>​      删除widget，widget必须是该MdiArea的子部件</p><p>​      （10）void QMdiArea：：setActiveSubWindow（QMdiSubWindow *window）[slot]</p><p>​      设置子窗口window为当前活动子窗口</p><h4 id="DockWidget控件"><a href="#DockWidget控件" class="headerlink" title="DockWidget控件"></a>DockWidget控件</h4><p>​    1.控件位置：Containers-&gt;DockWidget</p><p>​    2.控件介绍：停靠窗体，可以作为一个顶层窗口漂浮在桌面，主要作为辅助窗体出现在界面中，可以在很多IDE中看到停靠窗体</p><p>​    3.控件属性设置选项</p><p>​      （1）name：同上</p><p>​      （2）font：同上</p><p>​      （3）floating：设置该DockWidget是否为可漂浮</p><p>​      （4）feature：保存的停靠窗体一些功能，是否为可移动，可关闭或浮动等，默认是可移动可关闭和浮动</p><p>​      （5）allowedArea：该DockWidget可以停靠的地方</p><p>​      （6）windowTitle：该停靠窗体的标题</p><p>​      （7）dockWidgetArea：设置该DockWidget的停靠地方</p><p>​      （8）docked：设置该DockWidget是否是停靠着的</p><p>​    4.常用成员函数</p><p>​      （1）QDockWidget：：QDockWidget（const QString &amp;title，QWidget *parent = 0，Qt：：WindowFlags flags = 0）</p><p>​      构造一个标题为title，父对象为parent的DockWidget</p><p>​      （2）QDockWidget：：QDockWidget（QWidget *parent = 0，Qt：：WindowFlags flags = 0）</p><p>​      构造一个父对象为parent和标志位flags的DockWidget</p><p>​      （3）void QDockWidget：：setTitleBarWidget（QWidget *widget）</p><p>​      设置widget为该DockWidget的标题栏，如果widget为0，将用默认标题栏代替</p><p>​      （4）QWidget *QDockWidget：：titleBarWidget（）const</p><p>​      返回该DockWidget定义的标题栏，如果没有定义标题栏，返回0</p><p>​      （5）void QDockWidget：：setWidget（QWidget *widget）</p><p>​      设置widget为该DockWidget的部件，在调用这个函数之前，必须添加布局，否则widget就是不可见的</p><p>​      （6）QWidget *DockWidget：：widget（）const</p><p>​      返回该DockWidget的部件，如果没有设置部件，则返回0</p><h3 id="Input-Widgets"><a href="#Input-Widgets" class="headerlink" title="Input Widgets"></a>Input Widgets</h3><h4 id="ComboBox控件"><a href="#ComboBox控件" class="headerlink" title="ComboBox控件"></a>ComboBox控件</h4><p>  1.控件位置：Input Widgets-&gt;ComboBox</p><p>  2.控件介绍：略</p><p>  3.控件属性设置选项</p><p>​    （1）name：该控件对应源代码中的名称</p><p>​    （2）font：设置显示的字体</p><p>​    （3）editable：用来获取或设置一个值，以确定ComboBox的编辑框是否可编辑，值为true是为可编辑，值为false时只读</p><p>​    （4）currentIndex：当前选项的索引</p><p>​    （5）maxVisibleItems：ComboBox可见的最大项目数</p><p>​    （6）maxCount：ComboBox的最大项目数</p><p>  4.常用成员函数：</p><p>​    （1）QComboBox：：QComboBox（QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent的ComboBox</p><p>​    （2）QComboBox：：QComboBox（bool rw，QWidget *parent = 0，const char * name = 0）</p><p>​    构造一个名称为name，父对象为parent的ComboBox，如果rw是true，则编辑栏可编辑，否则只能选择ComboBox项目之一</p><p>​    （3）void QComboBox：：clear（）const</p><p>​    删除ComboBox中的所有项目</p><p>​    （4）int QComboBox：：count（）const</p><p>​    返回ComboBox中的项目数</p><p>​    （5）int QComboBox：：currentItem（）const</p><p>​    返回ComboBox中当前项目的索引</p><p>​    （6）QString QComboBox：：currentText（）const</p><p>​    返回组合框的当前项目文本</p><p>​    （7）void QComboBox：：insertItem（const QString &amp;t，int index = -1）</p><p>​    在索引index处插入一个文本为t的项目，如果index是负数，该项目将被追加到末尾</p><p>​    （8）void QComboBox；：insertItem（const QPixmap &amp;pixmap，int index = -1）</p><p>​    在索引index处插入一个图标为pixmap的项目，如果index为负数，该项目将被追加到末尾</p><p>​    （9）void QComboBox：：insertItem（const QPixmap &amp;pixmap，const QString &amp;text，int index = -1）</p><p>​    在索引index处，插入一个文本为text和图标为pixmap的项目，如果index为负数，该项目将被追加到末尾</p><p>​    （10）QString QComboBox：：currentText（）const</p><p>​    返回组合框当前项目文本</p><p>​    （11）void QComboBox：：removeItem（int index）</p><p>​    删除索引为index处项目</p><p>​    （12）void QComboBox：：setCurrentItem（int index）[virtual]</p><p>​    把索引index处的项目设为当前项目</p><h4 id="Font-ComboBox控件"><a href="#Font-ComboBox控件" class="headerlink" title="Font ComboBox控件"></a>Font ComboBox控件</h4><p>  1.控件位置：Input Widgets-&gt;Font ComboBox</p><p>  2.控件介绍：字体组合框继承于QComboBox类，Font ComboBox组合框分为两部分显示：顶部是一个允许输入文本的文本框，下面的列表框则显示列表项，Font ConboBox就是文本框与列表框的组合，但是不能选择多项，只能选择其中一项，专门用于字体选择</p><p>  3.控件属性设置选项</p><p>​    （1）name：同上</p><p>​    （2）font：同上</p><p>​    （3）editable：用来获取或设置一个值，以确定ComboBox的编辑框是否可编辑，值为true时为可编辑，值为false时为只读</p><p>​    （4）currentIndex：当前选项的索引</p><p>​    （5）currentFont：当前字体</p><p>​    （6）maxVisibleItems：ComboBox可见的最大项目数</p><p>​    （7）maxCOunt：ComboBox的最大项目数</p><p>  4.常用成员函数</p><p>​    （1）QFontComboBox：：QFontComboBox（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的Font ComboBox</p><h4 id="LineEdit控件"><a href="#LineEdit控件" class="headerlink" title="LineEdit控件"></a>LineEdit控件</h4><p>  1.控件位置：Input Widgets-&gt;LineEdit<br>  2.控件介绍：行编辑是一种常用且比较容易掌握的控件，应用程序主要用它来接收输入文字信息。<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）text：同上<br>​    （3）font：同上<br>​    （4）ReadOnly：用来获取或设置一个值，该值指示文本框中的文本是否为只读，值为true时为只读，值为false为可读写</p><p>  4.常用成员函数</p><p>​    （1）QLineEidt：：QLineEdit（QWidget *parent，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent的LineEdit</p><p>​    （2）QLineEdit：：QLineEdit（const QString &amp;contents,QWidget *parent，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent和内容为contents的LineEdit</p><p>​    （3）void QLineEdit：：clear（）[virtual slot]</p><p>​    清除行编辑的内容</p><p>​    （4）bool QLineEdit：：isReadOnly（）const</p><p>​    如果行编辑室只读则返回true，否则返回false</p><p>​    （5）void QLineEdit：：setReadOnly（bool）[virtual slot]</p><p>​    设置行编辑的读写属性</p><p>​    （6）void QLineEdit：：setText（const QString &amp;）[virtual slot]</p><p>​    设置行编辑的文本</p><p>​    （7）QString QLineEdit：：text（）const</p><p>​    返回行编辑的文本</p><h4 id="TextEdit控件"><a href="#TextEdit控件" class="headerlink" title="TextEdit控件"></a>TextEdit控件</h4><p>  1.控件位置：Input Widgets-&gt;TextEdit</p><p>  2.控件介绍：文本编辑控件主要用它输入文本信息或显示文本信息，TextEdit的属性和成员函数与LineEdit基本相同。</p><h4 id="PlainTextEdit控件"><a href="#PlainTextEdit控件" class="headerlink" title="PlainTextEdit控件"></a>PlainTextEdit控件</h4><p>  1.控件位置：Input Widgets-&gt;PlainTextEdit<br>  2.控件介绍：PlainTextEdit控件中文称作“文本编辑“，PlainTextEdit和TextEdit控件只是样式不同，可以通过设置属性来改变样式<br>  3.常用成员函数</p><p>​    （1）QPlainTextEdit：：QPlainTextEdit（QWidget *parent = 0）<br>​    （2）QPlainTextEdit：：QPlainTextEdit（const QString &amp;text，QWidget *parent = 0）</p><h4 id="SpinBox控件"><a href="#SpinBox控件" class="headerlink" title="SpinBox控件"></a>SpinBox控件</h4><p>  1.控件位置：Input Widgets-&gt;SpinBox<br>  2.控件介绍：整数旋转框允许用户通过单击向上/向下按钮来增加/减少当前显示的值，也可以直接输入旋转框的值，如果该值是直接输入选择框，一般需要按Enter键确认新值。有的版本不需要，该值通常是一个整数。<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）font：同上<br>​    （3）value：SpinBox默认值<br>​    （4）lineStep；使用箭头来改变选择框的值的递增/递减量<br>​    （5）minValue：SpinBox的最小值<br>​    （6）maxValue：SpinBox的最大值<br>​    （7）prefix：SpinBox的前缀字符串<br>​    （8）Suffix：SpinBox的后缀字符串</p><p>  4.常用成员函数</p><p>​    （1）QSpinBox：：QSpinBox（QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent的SpinBox</p><p>​    （2）QSpinBox：：QSpinBox（int intValue，int maxValue，int step = 1，QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent，最小值为minValue，最大值为maxValue和增/减量为step的SpinBox</p><p>​    （3）void QSpinBox：：stepDown（）[virtural slot]</p><p>​    把旋转框的值减少一个lineStep，等同于单击向下按钮</p><p>​    （4）void QSpinBox：：stepUp（）[virtual slot]</p><p>​    把旋转框的值增加一个lineStep，等于单击向上按钮</p><p>​    （5）QString QSpinBox：：text（）const</p><p>​    返回旋转框的文本，包括前缀和后缀</p><p>​    （6）int QSpinBox：：value（）const</p><p>​    返回旋转框的值</p><p>​    （7）void QSpinBox：：setValue（int value）[virtual slot]</p><p>​    设置旋转框的值</p><p>​    （8）void QSpinBox：：setLineStep（int）</p><p>​    设置旋转框的增/减量</p><p>​    （9）void QSpinBox：：setMaxValue（int）</p><p>​    设置旋转框的最大值</p><p>​    （10）void QSpinBox：：setMinValue（int）</p><p>​    设置旋转框的最小值</p><p>​    （11）void QSpinBox：：setPrefix（const QString &amp;text）[virtual slot]</p><p>​    设置旋转框的前缀字符</p><p>​    （12）void QSpinBox：：setSuffix（const QString &amp;text）[virtual slot]</p><p>​    设置旋转框的后缀字符</p><h4 id="Double-SpinBox"><a href="#Double-SpinBox" class="headerlink" title="Double SpinBox"></a>Double SpinBox</h4><p>  1.控件位置：Input-&gt;Double SpinBox</p><p>  2.控件介绍：小数旋转框，继承与QSpinBox，可以表示小数，其他与QSpinBox功能相同</p><p>  3.控件属性设置选项</p><p>​    （1）name：同上</p><p>​    （2）font：同上</p><p>​    （3）value：SpinBox默认值</p><p>​    （4）lineStep：同上</p><p>​    （5）minValue：同上</p><p>​    （6）maxValue：同上</p><p>​    （7）prefix：SpinBox的前缀字符</p><p>​    （8）Suffix：SpinBox的后缀字符</p><p>​    （9）decimals：SpinBox的小数位数</p><p>  4.常用成员函数</p><p>​    （1）QDoubleSpinBox：：QDoubleSpinBox（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的Double SpinBox</p><h4 id="Slider控件"><a href="#Slider控件" class="headerlink" title="Slider控件"></a>Slider控件</h4><p>  1.控件位置：Input Widgets-&gt;Horizontal/Vertical Slider<br>  2.控件介绍：滑动条分为Horizontal/Vertical Slider两个控件，但功能相同，两种滑动条之间可以相互转换，只需改变orientation属性即可<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）font：同上<br>​    （3）lineStep：滑动条值的最小跨度<br>​    （4）value：滑动条的值<br>​    （5）minValue；滑动条的最小值<br>​    （6）maxValue：滑动条的最大值<br>​    （7）orientation：滑动条的布局方向，Qt提供Horizontal/Vertical Slider两种选择</p><p>  4.常用成员函数</p><p>​    （1）QSlider：：QSlider（QWidget *parent，const char *name =0）</p><p>​    构造一个名称为name，父对象为parent的Slider</p><p>​    （2）QSlider：：QSlider（Qrientation orientation，QWidget *parent，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent，布局方向为orientation的Slider</p><p>​    （3）QSlider：：QSlider（int minValue，int maxValue，int pageStep，int value，Orientation orientation，QWidget *parent，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent，布局方向为orientation，最大值为maxValue，最小值为minValue，页步长为pageStep和值为value的Slider</p><p>​    （4）void QSlider：：setValue（int v）[virtual slot]</p><p>​    设置该滑动条的值为v</p><p>​    （5）int QSlider：：value（）const</p><p>​    返回滑动条的值</p><h4 id="Dial控件"><a href="#Dial控件" class="headerlink" title="Dial控件"></a>Dial控件</h4><p>  1.控件位置：Input Widgets-&gt;Dial<br>  2.控件介绍：表盘控件可用来描述各式各样的仪表盘样式<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）font：同上<br>​    （3）lineStep：表盘值的最小跨度<br>​    （4）value：表盘的值<br>​    （5）minValue：表盘的最小值<br>​    （6）maxValue：表盘的最大值<br>​    （7）notchTarget：表盘的刻度<br>​    （8）notchesVisible：是否显示表盘刻度，值为true时显示，否则不显示</p><p>  4.常用成员函数</p><p>​    （1）QDial：：QDial（QWidget *parent = 0，cosnt char *name = 0，WFlags f = 0）</p><p>​    构造一个名称为name，父对象为parent的Dial</p><p>​    （2）QDial：：QDial（int minValue，int maxValue，int pageStep，int value，QWidget *parent = 0，cosnt char *name = 0</p><p>​    构造一个名称为name，父对象为parent，最大值为maxValue，最小值为minValue，步长为pageStep，值为value的Dial</p><p>​    （3）void QDial：：setValue（int v）[virtual slot]</p><p>​    设置该仪表盘的值为v</p><p>​    （4）int QDial：：value（）const</p><p>​    返回该表盘的值</p><h4 id="ScrollBar控件"><a href="#ScrollBar控件" class="headerlink" title="ScrollBar控件"></a>ScrollBar控件</h4><p>  1.控件位置：Input Widgets-&gt;Horizontal/Vertical ScrollBar<br>  2.控件介绍：滚动条ScrollBar和Slider相同。<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）font：设置滑动条上的字体<br>​    （3）lineStep：滑动条的最小跨度<br>​    （4）value：滑动条的值<br>​    （5）minValue：滑动条的最小值<br>​    （6）maxValue：滑动条的最大值<br>​    （7）orientation：滑动条的布局方向，Qt提供Horizontal/Vertical两种</p><p>  4.常用成员函数</p><p>​    （1）QScrollBar：：QScrollBar（QWidget *parent，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent的ScrollBar</p><p>​    （2）QScrollBar：：QScrollBar（Orientation orientation，QWidget *parent，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent，布局为orientation的ScrollBar</p><p>​    （3）void QScrollBar：：setValue（int v）[slot]</p><p>​    设置该滚动条的值为v</p><p>​    （4）int QScrollBar：：value（）const</p><p>​    返回滚动条的值</p><h4 id="DateEdit控件"><a href="#DateEdit控件" class="headerlink" title="DateEdit控件"></a>DateEdit控件</h4><p>  1.控件位置：Input Widgets-&gt;DateEdit</p><p>  2.控件介绍：日期编辑框用于编辑和显示日期的控件</p><p>  3.控件属性设置选项</p><p>​    （1）name：同上</p><p>​    （2）font：同上</p><p>​    （3）date：显示的日期</p><p>​    （4）minValue：日期的最小值</p><p>​    （5）maxValue：日期的最大字画</p><p>​    （6）order：设置日期显示格式，Qt提供的格式有YMD、YDM、DMY</p><p>  4.常用成员函数</p><p>​    （1）QDateEdit：：QDateEdit（QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent的DateEdit</p><p>​    （2）QDateEdit：：QDateEdit（const QDate &amp;date，QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名字为name，父对象为parent，当前显示日期为date的DateEdit，</p><p>​    （3）QDate QDateEdit：：date（）const</p><p>​    返回DateEdit控件的Date值</p><p>​    （4）void QDateEdit：：setDate（const QDate &amp;date）[virtual]</p><p>​    设置DateEdit控件Date的值为date</p><p>​    （5）void QDateEdit：：setDay（int day）[virtual protected]</p><p>​    设置DateEdit控件Date的Day为day，必须确保day为有效值</p><p>​    （6）void QDateEdit：：setMonth（int month）[virtual protected]</p><p>​    设置DateEdit控件Date的Month为month，必须确保month为有效值</p><p>​    （7）void QDateEdit：：setYear（int year）[virtual protected]</p><p>​    设置DateEdit控件Date的Year为year，必须确保year为有效值</p><h4 id="TimeEdit控件"><a href="#TimeEdit控件" class="headerlink" title="TimeEdit控件"></a>TimeEdit控件</h4><p>  1.控件位置：Input Widgets-&gt;TimeEdit</p><p>  2.控件介绍：用来编辑和显示时间的控件</p><p>  3.控件属性设置选项</p><p>​    （1）name：同上</p><p>​    （2）font：设置文本框的字体</p><p>​    （3）time：显示的日期</p><p>​    （4）minValue：时间的最小值</p><p>​    （5）maxValue：时间的最大值</p><p>​    （6）display：设置时间显示格式</p><p>  4.常用成员函数</p><p>​    （1）QTimeEdit：：QTimeEdit（QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent的TimeEdit</p><p>​    （2）QTimeEdit：：QTimeEdit（const QTime &amp;time，QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent，当前显示时间为time的TimeEdit</p><p>​    （3）QTime QTimeEdit：：time（）const</p><p>​    返回TimeEdit控件Time的值</p><p>​    （4）void QTimeEdit：：setTime（const QTime &amp;time）[virtural]</p><p>​    设置TimeEdit控件为Time的值time</p><p>​    （5）void QTimeEdit：：setHour（int h）[virtural protected]</p><p>​    设置TimeEdit控件Time的Hour为h，必须确保h为有效值</p><p>​    （6）void QTimeEdit：：setMinute（int m）[virtual protected]</p><p>​    设置TimeEdit控件Time的Minute为m，必须确保m为有效值</p><p>​    （7）void QTimeEdit：：setSecond（int s）[virtual protected]</p><p>​    设置TimeEdit控件Time的Second为s，必须确保s为有效值</p><h4 id="DateEdit控件-1"><a href="#DateEdit控件-1" class="headerlink" title="DateEdit控件"></a>DateEdit控件</h4><p>  1.控件位置：Input Widgets-&gt;DateTimeEdit<br>  2.控件介绍：日期时间编辑框是一个用来编辑和显示日期和时间的控件，相当于把DateEdit和TimeEdit联合起来使用<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）font：设置文本框的字体<br>​    （3）datetime：显示的日期和时间</p><h3 id="Display-Widgets"><a href="#Display-Widgets" class="headerlink" title="Display Widgets"></a>Display Widgets</h3><h4 id="Label控件"><a href="#Label控件" class="headerlink" title="Label控件"></a>Label控件</h4><p>  1.控件位置：DisplayWidgets-&gt;Label</p><p>  2.控件介绍：略</p><p>  3.控件属性设置选项</p><p>​    （1）name：该控件对应源代码中的名称</p><p>​    （2）font：设置text的字体</p><p>​    （3）text：用来设置或返回标签控件中显示的文本信息</p><p>  4.常用成员函数</p><p>​    （1）QLabel：：QLabel（QWidget *parent，const char *name = 0，WFlags f = 0）</p><p>​    构造一个名称为name，父对象为parent和标记为f的TextLabel</p><p>​    （2）QLabel：：QLabel（const QString &amp;text，QWidget *parent，const char *name = 0，WFlags f = 0）</p><p>​    构造一个名称为name，父对象为parent，标记符为f和内容为text的TextLabel</p><p>​    （3）void QLabel：：clear（）[slot]</p><p>​    清除标签内容</p><p>​    （4）void QLabel：：setText（const QString &amp;）[virtual slot]</p><p>​    设置标签的文本</p><p>​    （5）QString QLabel：：text（）const</p><p>​    返回标签的文本</p><h4 id="TextBrowser控件"><a href="#TextBrowser控件" class="headerlink" title="TextBrowser控件"></a>TextBrowser控件</h4><p>  1.控件位置：DisplayWidgets-&gt;TextBrowser<br>  2.控件介绍：文本浏览器继承自QTextEdit，TextBrowser是只读的，不允许对内容进行更改，但是相对于QTextEdit来讲，它还具有链接文本的作用<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）font：同上<br>​    （3）frameShape：边框样式<br>​    （4）frameShadow：边框阴影，Qt Designer提供了plain、raised、sunken<br>​    （5）lineWidth：边框线宽<br>​    （6）text：显示的文本<br>​    （7）source：显示的文件名称，如果没有文件显示或来源，则显示空字符串</p><p>  4.常用成员函数</p><p>​    （1）QTextBrowser：：QTextBrowser（！QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent的TextBrowser</p><p>​    （2）void QTextBrowser：：backward（）[virtual slot]</p><p>​    更改内置导航链接的文件清单为显示当前一个文档，如果没有以前的文档，就什么都不做，可以实现向前翻页的功能</p><p>​    （3）void QTextBrowser：：forward（）[virtual slot]</p><p>​    更改内置导航链接的文件清单为显示下一个文档文件，如果没有以前的文档，就什么都不做，可以实现向后翻页的功能</p><p>​    （4）void QTextBrowser：：home（）[virtual slot]</p><p>​    更改显示的文件浏览器中的链接，显示第一个文件</p><p>​    （5）void QTextBrowser：：linkClicked（const QString &amp;name）[virtual slot]</p><p>​    当单击链接时，发射该信号</p><p>​    （6）void QTextBrowser：：reload（）[virtual slot]</p><p>​    重新载入当前的设置源</p><p>​    （7）void QTextBrowser：：setSource（const QString &amp;name）[virtual slot]</p><p>​    设置当前显示的文件名称为name</p><p>​    （8）QString QTextBrowser：：source（）const</p><p>​    返回当前显示的文件的文件名称</p><h4 id="GraphicsView控件"><a href="#GraphicsView控件" class="headerlink" title="GraphicsView控件"></a>GraphicsView控件</h4><p>  1.控件位置：DisplayWidgets-&gt;GraphicsView</p><p>  2.控件介绍：绘图视图是用于显示QGraphicsScene内容的控件，GraphicsView框架为2D绘图提供一个简单、容易使用、功能强大的解决方案。GraphicsView框架由三个主要的类组成：QGraphicsItem、QGraphicsScene和QGraphicsView。其中QGraphicsItem定义图元，QGraphicsScene定义场景，包含所有需要绘制的图元，根据用户的操作改变图元的状态。QGraphicsView定义观察场景的视窗，可以充当绘图的区域，成为独立的窗体被弹出，或者嵌入其他UI组件中形成符合UI组件</p><p>  3.控件属性设置选项</p><p>​    （1）name：同上</p><p>​    （2）font：同上</p><p>​    （3）frameShape：边框样式</p><p>​    （4）frameShadow：边框阴影，Qt提供了plain、raise、sunken</p><p>​    （5）lineWidth：边框线宽</p><p>  4.常用成员函数</p><p>​    （1）QGraphicsView：：QGraphicsView（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的GraphicsView</p><p>​    （2）QGraphicsView：：QGraphicsView（QGraphicsScene *scene，QWidget *parent = 0）</p><p>​    构造一个父对象为parent的GraphicsView，填充场景scene到该GraphicsView</p><p>​    （3）void QGraphicsView：：centerOn（const QPointF &amp;pos）</p><p>​    调整视窗的内容，确保点pos在视窗中居中</p><p>​    （4）void QGraphicsView：：centerOn（qreal x，qreal y）</p><p>​    这是一个重载函数，同函数（3），相当于调用center（QPointF（x，y））</p><p>​    （5）void QGraphicsView：：centerOn（const QGraphicsItem *item）</p><p>​    这是一个重载函数，功能同（3），调整视区的内容，使项目item为中心</p><p>​    （6）void QGraphicsView：：ensureVisible（const QRectF &amp;rect，int xmargin = 50，int ymargin = 50）</p><p>​    调整视窗的内容，使视窗rect中的内容是可见的</p><p>​    （7）void QGraphicsView：：ensureVisible（qreal x，qreal y，qreal w，qreal h，int xmargin = 50，int ymargin = 50）</p><p>​    这是一个重载函数，函数功能同（6），相当于调用ensureVisible（QRectF（x，y，w，h），xmargin，ymargin）</p><p>​    （8）void QGraphicsView：：ensureVisible（const QGraphicsItem *item，int xmargin = 50，int ymargin = 50）</p><p>​    这是一个重载函数，功能同（6）调整视窗的内容，使item的内容可见</p><p>​    （9）QGraphicsItem *QGraphicsView：：itemAt（const QPoint &amp;pos）const</p><p>​    返回pos处的item</p><p>​    （10）QGraphicsItem *QGraphicsView：：itemAt（int x，int y）const</p><p>​    这是一个重载函数，功能同（9），返回坐标（x，y）处的item</p><p>​    （11）QList&lt;QGraphicsItem *&gt; QGraphicsView：：items（）const</p><p>​    返回相关场景中的所有图元</p><p>​    （12）QList&lt;QGraphicsItem *&gt; QGraphicsView：：items（const QPoint &amp;pos）const</p><p>​    返回视图中位置pos处的项目列表</p><p>​    （13）QGraphicsScene *QGraphicsView：：scene（）const</p><p>​    返回当前可视化的场景，如果当前没有可视化的场景，则返回0</p><p>​    （14）void QGraphicsView：：setScene（QGraphicsScene *scene）</p><p>​    设置场景scene为当前可视化场景</p><p>​    （15）void QGraphicsView：：updateScene（const QList<QRectF> &amp;rects）[slot]</QRectF></p><p>​    更新场景</p><h4 id="Calendar控件"><a href="#Calendar控件" class="headerlink" title="Calendar控件"></a>Calendar控件</h4><p>  1.控件位置：DisplayWidgets-&gt;Calendar<br>  2.控件介绍：日历控件<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）font：同上<br>​    （3）selectdDate：当前日期<br>​    （4）minimumDate：该日历控件能够显示的最小日期<br>​    （5）maxmumDate：该日历控件能够显示的最大日期<br>​    （6）firstDayOfWeek：每星期的第一天<br>​    （7）gridVisible：是否显示网格<br>​    （8）dateEditEnable：是否允许编辑日历</p><p>  4.常用成员函数</p><p>​    （1）QCalendarWidget：：QCalendarWidget（QWidget *parent = 0）</p><p>​    构造一个父对象为parent的Calendar</p><p>​    （2）int QCalendarWidget：：monthShown（）const</p><p>​    但会当前显示的月份</p><p>​    （3）void QCalendarWidget：：setCurrentPage（int year，int month）[slot]</p><p>​    显示给定的年份和月份</p><p>​    （4）void QCalendarWidget：：setDateRange（const QDate &amp;min，const QDate &amp;max）[slot]</p><p>​    设置该Calendar的显示范围，最小日期为min，最大日期为max</p><p>​    （5）void QCalendarWidget：：showSelectedDate（）[slot]</p><p>​    显示当前选中的日期</p><p>​    （6）void QCalendarWidget：：showToday（）[slot]</p><p>​    显示系统当前日期</p><p>​    （7）int QCalendarWidget：：yearShown（）const</p><p>​    返回当前显示的年份</p><h4 id="LCDNumber控件"><a href="#LCDNumber控件" class="headerlink" title="LCDNumber控件"></a>LCDNumber控件</h4><p>  1.控件位置：DisplayWidgets-&gt;LCDNumber</p><p>  2.控件介绍：LCD数字显示框可以显示十六进制，十进制，八进制或二进制数</p><p>  3.控件属性设置选项</p><p>​    （1）name：同上</p><p>​    （2）font：设置显示框字体</p><p>​    （3）frameShape：同上</p><p>​    （4）frameShadow：同上</p><p>​    （5）lineWidth：同上</p><p>​    （6）mode：设置显示格式，Qt提供十六进制、十进制、八进制、二进制格式</p><p>​    （7）value：该LCDNumber的值</p><p>​    （8）intValue：该LCDNumber的整数值</p><p>​    （9）numDigits：显示框最大可以显示的数字位数</p><p>  4.常用成员函数</p><p>​    （1）QLCDNumber：：QLCDNumber（QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent的LCDNumber</p><p>​    （2）QLCDNumber：：QLCDNumber（uint numDigits，QWidget *parent = 0，const char *name = 0）</p><p>​    构造一个名称为name，父对象为parent和显示框最大可以显示的数字位数为numDigits的LCDNumber、</p><p>​    （3）void QLCDnumber：：display（int num）[slot]</p><p>​    设置显示的值为num</p><p>​    （4）void QLCDNumber：：display（const QString &amp;s）[slot]</p><p>​    重载函数，功能同（3）显示s</p><p>​    （5）void QLCDNumber：：display（double num）[slot]</p><p>​    重载函数，功能同（3），显示num</p><p>​    （6）int QLCDNumber：：intValue（）const</p><p>​    返回显示值的整数值，对应intValue属性</p><p>​    （7）int QLCDNumber：：numDigits（）const</p><p>​    返回显示框最大可以显示的数字位数，对应numDigits属性</p><p>​    （8）double QLCDNumber：：value（）const</p><p>​    返回该LCDNumber显示的值</p><h4 id="ProgressBar控件"><a href="#ProgressBar控件" class="headerlink" title="ProgressBar控件"></a>ProgressBar控件</h4><p>  1.控件位置：DisplayWidgets-&gt;ProgressBar<br>  2.控件介绍：进度条显示为一个水平进度条，一个进度条是用来给用户显示操作进度的，证明他们的应用程序还在运行，进度条控件非常常见<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）font：同上<br>​    （3）frameShape：边框样式<br>​    （4）frameShadow：边框阴影<br>​    （5）lineWidth：边框线宽<br>​    （6）progress：进度条当前的进度值</p><p>  4.常用成员函数</p><p>​    （1）QProgressBar：：QProgressBar（QWidget *parent = 0，const char *name = 0，WFlags f = 0）</p><p>​    构造一个名字为name，父对象为parent的ProgressBar</p><p>​    （2）QProgressBar：：QProgressBar（int totalSteps，QWidget *parent = 0，const char *name = 0，WFlags f = 0）</p><p>​    构造一个名称为name，父对象为parent和总的进度值为totalSteps的ProgressBar。</p><p>​    （3）int QProgressBar：：progress（）cosnt</p><p>​    返回当前进度条的进度值</p><p>​    （4）void QProgressBar：：setProgerss（int progress）[virtual slot]</p><p>​    设置该进度条的当前进度值为progress</p><p>​    （5）void QProgressBar：：reset（）[slot]</p><p>​    把进度条恢复到初始状态</p><h4 id="Line控件"><a href="#Line控件" class="headerlink" title="Line控件"></a>Line控件</h4><p>  1.控件位置：DisplayWidgets-&gt;Horizontal/Vertical Line<br>  2.控件介绍：线条用来装饰界面的控件，在界面中适当添加Line控件可以使界面更加美观、清晰<br>  3.控件属性设置选项</p><p>​    （1）name：同上<br>​    （2）frameShadow：plain、raised、sunken<br>​    （3）lineWidth：线条线宽<br>​    （4）orientation：线条布局方向</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Buttons&quot;&gt;&lt;a href=&quot;#Buttons&quot; class=&quot;headerlink&quot; title=&quot;Buttons&quot;&gt;&lt;/a&gt;Buttons&lt;/h3&gt;&lt;h4 id=&quot;PushButton控件&quot;&gt;&lt;a href=&quot;#PushButton控件&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt常用快捷方式</title>
    <link href="http://example.com/2021/04/14/QT%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2021/04/14/QT%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</id>
    <published>2021-04-13T16:06:31.000Z</published>
    <updated>2021-04-14T12:09:55.437Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">F1                                     查看帮助</span><br><span class="line">F2                                     跳转到函数定义（和Ctrl+鼠标左键一样的效果）</span><br><span class="line">Shift+F2                               声明和定义之间切换</span><br><span class="line">F4                                     头文件和源文件之间切换</span><br><span class="line">Ctrl+1                                 欢迎模式</span><br><span class="line">Ctrl+2                                 编辑模式</span><br><span class="line">Ctrl+3                                 调试模式</span><br><span class="line">Ctrl+4                                 项目设置模式</span><br><span class="line">Ctrl+5                                 帮助模式</span><br><span class="line">Ctrl+6                                 输出模式</span><br><span class="line">Alt+0                                  显示或者隐藏侧边条，编辑模式下起作用（有时写的函数太长，屏幕不够大，就用这个）</span><br><span class="line">Ctrl+Space                             自动补全（貌似会和输入法的切换冲突）</span><br><span class="line">ESc                                    切换到编辑模式</span><br><span class="line">Alt+1                                  创建细节窗口</span><br><span class="line">Alt+2                                  搜索结果窗口</span><br><span class="line">Alt+3                                  程序输出窗口</span><br><span class="line">Alt+4                                  编译输出窗口</span><br><span class="line">Ctrl+B                                 编译工程</span><br><span class="line">Ctrl+R                                 运行工程</span><br><span class="line">Ctrl+I                                 自动对齐</span><br><span class="line">Ctrl+/                                 注释行，取消注释行</span><br><span class="line">Ctrl+Shift+&lt;                           折叠代码块</span><br><span class="line">Ctrl+Shift+&gt;                           展开代码块</span><br><span class="line">Ctrl+[                                 跳到代码块的头部</span><br><span class="line">Ctrl+]                                 跳到代码块的尾部</span><br><span class="line">Ctrl+L                                 跳到某一行</span><br><span class="line">Ctrl+F                                 查找替换当前选中的内容，按下Ctrl+F，会列出所有和你选的内容一样的语句</span><br><span class="line">Ctrl+Shift+F                           查找内容</span><br><span class="line">Ctrl + k                               打开定位器（locator）</span><br><span class="line">Ctrl + Shift + f                       打开全局搜索框</span><br><span class="line">Ctrl + f                               打开当前页面搜索框</span><br><span class="line">Ctrl + 鼠标滚轮                         缩放代码</span><br><span class="line">Ctrl + /                               注释或取消注释</span><br><span class="line">Alt + 回车                 快速修复，如为头文件中的方法添加实现，或为实现添加头文件中声明，为字符串增加多语言支持等</span><br><span class="line">Ctrl + Shift +r                        查找替换当前工程的 特定字符，可以使类名或方法名，方便重构操作。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Python小结</title>
    <link href="http://example.com/2021/04/04/python%E5%B0%8F%E7%BB%93/"/>
    <id>http://example.com/2021/04/04/python%E5%B0%8F%E7%BB%93/</id>
    <published>2021-04-04T15:56:08.000Z</published>
    <updated>2021-04-14T12:10:11.641Z</updated>
    
    <content type="html"><![CDATA[<p>三周学完了pyhton，可喜可贺，可喜可贺。</p><hr><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数；</p><p>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数。</p><p>list和tuple是Python内置的有序集合，一个可变，一个不可变。</p><p>dict内部存放的顺序和key放入的顺序是没有关系的。</p><p>dict的key必须是不可变对象。</p><p>set和dict类似，也是一组key的集合，但不存储value。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>可以返回多个变量，实际上返回一个tuple。</p><p>定义默认参数要牢记一点：默认参数必须指向不变对象！</p><p>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p>在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p><p>变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p><p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</p><h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>闭包：相关参数和变量都保存在返回的函数中。</p><p>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</p><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的</p><p>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。</p><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>类的方法除了第一个参数是<code>self</code>外，其他和普通函数一样，而调用时除了<code>self</code>不用传递，其他参数正常传入</p><p>实例属性属于各个实例所有，互不干扰；</p><p>类属性属于类所有，所有实例共享一个属性；</p><p>千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><h3 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h3><p>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的。</p><p>Python允许使用多重继承，MixIn就是一种常见的设计。</p><p>Python的class允许定义许多定制方法，可以让我们非常方便地生成特定的类。</p><p>metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。</p><h3 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h3><p><code>logging</code>的一个好处是它允许你指定记录信息的级别，另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方。</p><p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p><p>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</p><p>单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。</p><p>单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</p><p>doctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来</p><h3 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h3><p>只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用<code>close()</code>的后果是数据可能只写了一部分到磁盘，剩下的丢失了。</p><p>Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法。</p><p>变量从内存中变成可存储或传输的过程称之为序列化。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化。</p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>线程是最小的执行单元，而进程由至少一个线程组成。</p><p>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。</p><p>一个<code>ThreadLocal</code>变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<code>ThreadLocal</code>解决了参数在一个线程中各个函数之间互相传递的问题。</p><p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）</p><p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>单线程的异步编程模型称为协程。</p><p>在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;三周学完了pyhton，可喜可贺，可喜可贺。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;&lt;code&gt;/&lt;/code&gt;除法计算结果是浮点数，即使是两个整数恰好整</summary>
      
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
</feed>
